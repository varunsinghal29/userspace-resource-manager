// Copyright (c) Qualcomm Technologies, Inc. and/or its subsidiaries.
// SPDX-License-Identifier: BSD-3-Clause-Clear

#include "ErrCodes.h"
#include "UrmPlatformAL.h"
#include "Utils.h"
#include "TestUtils.h"
#include "TestBaseline.h"
#include "URMTests.h"
#include "UrmAPIs.h"

#define TEST_CLASS "INTEGRATION"

static TestBaseline baseline;

typedef struct {
    std::string name;
    int32_t expectedValue;
    int32_t originalValue;
} ResourceHolder;

/*
 * These tests mirror the Client Perspective, i.e. how the client interacts with various
 * Resource Tuner APIs like tuneResources / untuneResources, tuneSignal etc.
 * The results of these are evaluated by validating the Resource Nodes.
 * As part of these Tests Request Verification and Application are Covered.
 */

/*
 * Description:
 * Handles generated by Resource Tuner Server, serve as Request Idenitfiers.
 * A unique handle is generated for each Tune Request (tuneResources and tuneSignal)
 * Handle Generation begins from "1" and increments by 1 with each new request.
 * Here we submit 3 sequential Requests, and verify that the correct handle is received
 * corresponding to each Request, i.e. 1 for R1, 2 for R2 and 3 for R3.
 */
URM_TEST(TestHandleGeneration, {
    SysResource* resourceList = new SysResource[1];
    memset(&resourceList[0], 0, sizeof(SysResource));
    resourceList[0].mResCode = CONSTRUCT_RES_CODE(0xff, 0x0002);
    resourceList[0].mNumValues = 1;
    resourceList[0].mResValue.value = 554;

    int64_t handle = tuneResources(2000, 0, 1, resourceList);

    delete[] resourceList;

    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;
    E_ASSERT((handle > 0));

    std::this_thread::sleep_for(std::chrono::seconds(3));

    resourceList = new SysResource[1];
    memset(&resourceList[0], 0, sizeof(SysResource));
    resourceList[0].mResCode = CONSTRUCT_RES_CODE(0xff, 0x0002);
    resourceList[0].mNumValues = 1;
    resourceList[0].mResValue.value = 667;

    handle = tuneResources(2000, 0, 1, resourceList);

    delete[] resourceList;

    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;
    E_ASSERT((handle > 0));

    std::this_thread::sleep_for(std::chrono::seconds(3));

    resourceList = new SysResource[1];
    memset(&resourceList[0], 0, sizeof(SysResource));
    resourceList[0].mResCode = CONSTRUCT_RES_CODE(0x0f, 0x0002);
    resourceList[0].mNumValues = 1;
    resourceList[0].mResValue.value = 701;

    handle = tuneResources(2000, 0, 1, resourceList);

    delete[] resourceList;

    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;
    E_ASSERT((handle > 0));
})

URM_TEST(TestPropFetch, {
    char prop1[] = "resource_tuner.pulse.duration";
    char buf[64];
    memset(buf, 0, sizeof(buf));

    int8_t status = getProp(prop1, buf, sizeof(buf), "na");
    E_ASSERT((status == 0));

    std::cout<<LOG_BASE<<"Value Fetched for key: ["<<prop1<<"] is: "<<buf<<std::endl;
    E_ASSERT((std::string(buf) == "60000000"));

    char prop2[] = "resource_tuner.maximum.concurrent.requests";
    memset(buf, 0, sizeof(buf));

    status = getProp(prop2, buf, sizeof(buf), "na");
    E_ASSERT((status == 0));

    std::cout<<LOG_BASE<<"Value Fetched for key: ["<<prop2<<"] is: "<<buf<<std::endl;
    E_ASSERT((std::string(buf) == "60"));

    // Non Existent
    char prop3[] = "resource_tuner.benchmark.comparison.utilinets";
    memset(buf, 0, sizeof(buf));

    status = getProp(prop3, buf, sizeof(buf), "na");
    E_ASSERT((status == 0));

    std::cout<<LOG_BASE<<"Value Fetched for key: ["<<prop3<<"] is: "<<buf<<std::endl;
    E_ASSERT((std::string(buf) == "na"));
})

/*
 * Description:
 * This Section contains tests which aim to verify the correctness of the Verifier.
 * The Verifier is responsible for validating the Tune Request on various param before
 * handing it to the RequestQueue for application. Specifically it checks the following params:
 * - Request Level Tests
 *   - Sanity Tests
 *       - Request should have a positive duration (with the exception of -1) [A]
 *       - Request should specify a non-zero number of Resources to Tune [B]
 *       - Request should have a valid Priority i.e. either HIGH (0) or LOW (1) [D]
 * - Resource Level Tests
 *   - Verifier will iterate over all the Resources part of the Request, and perform the following
 *     tests on each of them. Note if any test fails for any (even one) Resource part of the Request,
 *     then the entire Request shall be dropped.
 *   - Sanity Tests
 *       - Each Resource with the specified ID should exist in the Resource Registry [E]
 *   - Application Tests
 *       - The configured value for the Resource should be in the Range LT, HT as specified by the
 *         Resource Config [F]
 *       - If the Resource has a core level conflict, then Logical to Physical Mapping happens
 *         as part of the Verifier, if the translation cannot be performed then the Request is dropped. [G]
 *       - If the Resource does not support tuning, then the Request will be dropped. [H]
 *       - Check if the Resorce can be tuned in the current System mode. Note, each Resource can specify
 *         via Config, the list of Modes (for example: Display On, Doze) it can be tuned in. [I]
 *   - Permission Check:
 *       - Each Resource can specify a permission level, i.e. only the client with Permission level equal
 *         to or greater than what is specified in the Resource Config can tune that Resource. [J]
 * All the above mentioned cases are covered by the different tests under this section.
 * Note: While almost all the Request Verification happens on the Server end, however to save Server
 * Request Processing time, some very basic Request Verification happens on the Client side as well.
 * This includes testing for cases A, B and C.
 */

/**
 * API under test: Tune
 * - The client tries to send a Request with a duration of 0.
 * - The Request will fail
 *   preliminary tests on the Client side and won't be submitted to the Server,
 *   returning -1 to the End-Client.
 * Cross-Reference id: [A]
 */
URM_TEST(TestNullOrInvalidRequestVerification1, {
    int64_t handle = tuneResources(0, RequestPriority::REQ_PRIORITY_HIGH, 0, nullptr);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;
    E_ASSERT((handle == RC_REQ_SUBMISSION_FAILURE));
})

/**
 * API under test: Tune
 * - Resources List should be non-empty for the Request to be considered valid.
 * - Each of the Resource, part of this list should be non-null and valid as well.
 * - Here, a null Resources List is passed to the Tune API, the Request will fail
 *   preliminary tests on the Client side and won't be submitted to the Server,
 *   returning -1 to the End-Client.
 * Cross-Reference id: [B]
 */
URM_TEST(TestNullOrInvalidRequestVerification2, {
    int64_t handle = tuneResources(-1, RequestPriority::REQ_PRIORITY_HIGH, 0, nullptr);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;
    E_ASSERT((handle == RC_REQ_SUBMISSION_FAILURE));
})

/**
 * API under test: Tune
 * - Resources List should be non-empty for the Request to be considered valid.
 * - Each of the Resource, part of this list should be non-null and valid as well.
 * - Here a non-null Resources List is passed to the Tune API, however the only Resource part of
 *   the Request is invalid, hence the Request will fail the preliminary tests on the Client side
 *   and won't be submitted to the Server, returning -1 to the End-Client.
 * - For checking Resource validity, we check basic SysResource params like mResCode, mResInfo and verify
 *   that these values are sane.
 * Cross-Reference id: [B]
 */
URM_TEST(TestNullOrInvalidRequestVerification3, {
    SysResource* resourceList = new SysResource[1];
    memset(&resourceList[0], 0, sizeof(SysResource));
    resourceList[0].mResCode = -1;
    resourceList[0].mResInfo = -1;

    int64_t handle = tuneResources(-1, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;
    E_ASSERT((handle == RC_REQ_SUBMISSION_FAILURE));

    delete[] resourceList;
})

/**
 * API under test: Tune
 * - As part of the tune API call, the client specifies a desired priority for the Request,
 *   which is one of the following values:
 *    1. HIGH
 *    2. LOW
 * - If a Client passes a Priority Value other than these Values, then the Request will be dropped.
 * - Verify that the Valid Resource Node's value remains unchanged.
 * Cross-Reference id: [D]
 */
URM_TEST(TestClientPriorityAcquisitionVerification, {
    std::string testResourceName = "/etc/urm/tests/nodes/scaling_min_freq.txt";
    int32_t testResourceOriginalValue = 107;

    std::string value;
    int32_t originalValue, newValue;

    value = AuxRoutines::readFromFile(testResourceName);
    originalValue = C_STOI(value);
    E_ASSERT((originalValue == testResourceOriginalValue));

    SysResource* resourceList = new SysResource[1];
    memset(&resourceList[0], 0, sizeof(SysResource));
    resourceList[0].mResCode = CONSTRUCT_RES_CODE(0xff, 0x0002);
    resourceList[0].mNumValues = 1;
    resourceList[0].mResValue.value = 554;

    // Invalid Priority Value = 2
    int64_t handle = tuneResources(-1, 2, 1, resourceList);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

    std::this_thread::sleep_for(std::chrono::seconds(2));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    E_ASSERT((newValue == testResourceOriginalValue));

    delete[] resourceList;
})

/**
 * API under test: Tune
 * - A client sends a Resource(s) Provisioning Request to tune a resource for some (possibly inf) duration
 * - The resource in question does not exist in the Resource Registry, i.e. the Client
 * - has specified an invalid Resource ID. The Request should be dropped.
 * - Here we issue a Request with 2 Resources, only one of them is Valid.
 * - Since Verifier checks all the Resource part of the Request, hence when it detects
 *   that one of the Resource does not exist in the Registry, it will drop the Request.
 * - Verify that the Valid Resource Node's value remains unchanged.
 * Cross-Reference id: [E]
 */
URM_TEST(TestInvalidResourceTuning, {
    // Create a list of 2 Resources, where only one of them is valid
    std::string validResourceName = "/etc/urm/tests/nodes/scaling_min_freq.txt";
    int32_t validResourceOriginalValue = 107;

    std::string value;
    int32_t originalValue, newValue;

    value = AuxRoutines::readFromFile(validResourceName);
    originalValue = C_STOI(value);
    E_ASSERT((originalValue == validResourceOriginalValue));

    SysResource* resourceList = new SysResource[2];
    memset(&resourceList[0], 0, sizeof(SysResource));
    resourceList[0].mResCode = CONSTRUCT_RES_CODE(0xff, 0x0002);
    resourceList[0].mNumValues = 1;
    resourceList[0].mResValue.value = 554;

    // No Resource with this ID exists
    memset(&resourceList[1], 0, sizeof(SysResource));
    resourceList[1].mResCode = 12000;
    resourceList[1].mNumValues = 1;
    resourceList[1].mResValue.value = 597;

    int64_t handle = tuneResources(-1, RequestPriority::REQ_PRIORITY_HIGH, 2, resourceList);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

    std::this_thread::sleep_for(std::chrono::seconds(2));

    value = AuxRoutines::readFromFile(validResourceName);
    newValue = C_STOI(value);
    E_ASSERT((newValue == validResourceOriginalValue));

    delete[] resourceList;
})

/**
 * API under test: Tune
 * - A client sends a Resource(s) Provisioning Request to tune a resource for some (possibly inf) duration
 * - The resource in question has a "lower_is_better" policy.
 * - Each Resource has an associated Low Threshold (LT) and High Threshold (HT).
 * - If a client tries to configure a value which is (< LT) or (> HT), then the Reuqest
 *   should be rejected by the Verifier
 * - Verify that the Resource Node's value remains unchanged.
 * Cross-Reference id: [F]
 */
URM_TEST(OutOfBoundsResourceTuning, {
    std::string testResourceName = "/etc/urm/tests/nodes/scaling_min_freq.txt";
    int32_t testResourceOriginalValue = 107;

    std::string value;
    int32_t originalValue, newValue;

    value = AuxRoutines::readFromFile(testResourceName);
    originalValue = C_STOI(value);
    E_ASSERT((originalValue == testResourceOriginalValue));

    SysResource* resourceList = new SysResource[1];
    memset(&resourceList[0], 0, sizeof(SysResource));
    resourceList[0].mResCode = CONSTRUCT_RES_CODE(0xff, 0x0002);
    resourceList[0].mNumValues = 1;
    resourceList[0].mResValue.value = 1200;

    int64_t handle = tuneResources(-1, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

    std::this_thread::sleep_for(std::chrono::seconds(2));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    E_ASSERT((newValue == testResourceOriginalValue));

    delete[] resourceList;
})

/**
 * API under test: Tune
 * - As part of the tune API call, the client specifies the target Logical Cluster and Core, if
 *   the resource in question has Core Level Conflict.
 * - For such a Resource (part of the Request), Core / Cluster Logical To Physical Translation is
 *   needed.
 * - If the logical Core / Cluster value is invalid, or if translation cannot be performed then the
 *   Request is dropped.
 * - Here, we setup the values of logical Core and Cluster such that the Translation will fail.
 * - Verify that the Resource Node's value remains unchanged.
 * Cross-Reference id: [G]
 */
URM_TEST(ResourceLogicalToPhysicalTranslationVerification1, {
    std::string testResourceName = "/etc/urm/tests/nodes/target_test_resource2.txt";
    int32_t testResourceOriginalValue = 333;

    std::string value;
    int32_t originalValue, newValue;

    value = AuxRoutines::readFromFile(testResourceName);
    originalValue = C_STOI(value);
    E_ASSERT((originalValue == testResourceOriginalValue));

    SysResource* resourceList = new SysResource[1];
    memset(&resourceList[0], 0, sizeof(SysResource));
    resourceList[0].mResCode = CONSTRUCT_RES_CODE(0xff, 0x0005);
    resourceList[0].mNumValues = 1;
    resourceList[0].mResValue.value = 2300;
    resourceList[0].mResInfo = 0;
    // Invalid Translation
    resourceList[0].mResInfo = SET_RESOURCE_CLUSTER_VALUE(resourceList[0].mResInfo, 2);
    resourceList[0].mResInfo = SET_RESOURCE_CORE_VALUE(resourceList[0].mResInfo, 27);

    int64_t handle = tuneResources(-1, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

    std::this_thread::sleep_for(std::chrono::seconds(2));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    E_ASSERT((newValue == testResourceOriginalValue));

    delete[] resourceList;
})

/**
 * API under test: Tune
 * - As part of the tune API call, the client specifies the target Logical Cluster and Core, if
 *   the resource in question has Core Level Conflict.
 * - For such a Resource (part of the Request), Core / Cluster Logical To Physical Translation is
 *   needed.
 * - If the logical Core / Cluster value is invalid, or if translation cannot be performed then the
 *   Request is dropped.
 * - Here, we setup the values of logical Core and Cluster such that the Translation will fail.
 * - Verify that the Resource Node's value remains unchanged.
 * Cross-Reference id: [G]
 */
URM_TEST(ResourceLogicalToPhysicalTranslationVerification2, {
    std::string testResourceName = "/etc/urm/tests/nodes/target_test_resource2.txt";
    int32_t testResourceOriginalValue = 333;

    std::string value;
    int32_t originalValue, newValue;

    value = AuxRoutines::readFromFile(testResourceName);
    originalValue = C_STOI(value);
    E_ASSERT((originalValue == testResourceOriginalValue));

    SysResource* resourceList = new SysResource[2];
    memset(&resourceList[0], 0, sizeof(SysResource));
    resourceList[0].mResCode = CONSTRUCT_RES_CODE(0xff, 0x0005);
    resourceList[0].mNumValues = 1;
    resourceList[0].mResValue.value = 2300;
    resourceList[0].mResInfo = 0;
    // Invalid Translation
    resourceList[0].mResInfo = SET_RESOURCE_CLUSTER_VALUE(resourceList[0].mResInfo, 8);
    resourceList[0].mResInfo = SET_RESOURCE_CORE_VALUE(resourceList[0].mResInfo, 2);

    int64_t handle = tuneResources(-1, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

    std::this_thread::sleep_for(std::chrono::seconds(2));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    E_ASSERT((newValue == testResourceOriginalValue));

    delete[] resourceList;
})

/**
 * API under test: Tune
 * - As part of the tune API call, the client specifies the target Logical Cluster and Core, if
 *   the resource in question has Core Level Conflict.
 * - For such a Resource (part of the Request), Core / Cluster Logical To Physical Translation is
 *   needed.
 * - If the logical Core / Cluster value is invalid, or if translation cannot be performed then the
 *   Request is dropped.
 * - Here, we setup the values of logical Core and Cluster such that the Translation will succeed.
 * - Verify that the Resource Node's changes to the desired value.
 * - Verify that once the Request Expires, the Resource Node value is reset.
 * Cross-Reference id: [G]
 */
URM_TEST(ResourceLogicalToPhysicalTranslationVerification3, {
    int32_t physicalClusterID = baseline.getExpectedPhysicalCluster(0);
    if(physicalClusterID == -1) {
        LOG_SKIP("Logical Cluster: 0 not found on test device, Skipping Test Case")
        return;
    }

    std::string testResourceName = "/etc/urm/tests/nodes/target_test_resource2.txt";
    int32_t testResourceOriginalValue = 333;

    std::string value;
    int32_t originalValue, newValue;

    value = AuxRoutines::readFromFile(testResourceName);
    originalValue = C_STOI(value);
    E_ASSERT((originalValue == testResourceOriginalValue));

    SysResource* resourceList = new SysResource[1];
    memset(&resourceList[0], 0, sizeof(SysResource));
    resourceList[0].mResCode = CONSTRUCT_RES_CODE(0xff, 0x0005);
    resourceList[0].mNumValues = 1;
    resourceList[0].mResValue.value = 2300;
    resourceList[0].mResInfo = 0;

    // Translation should be valid here
    resourceList[0].mResInfo = SET_RESOURCE_CLUSTER_VALUE(resourceList[0].mResInfo, 0);
    resourceList[0].mResInfo = SET_RESOURCE_CORE_VALUE(resourceList[0].mResInfo, 1);

    int64_t handle = tuneResources(5000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

    std::this_thread::sleep_for(std::chrono::seconds(2));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    E_ASSERT((newValue == 2300));

    std::this_thread::sleep_for(std::chrono::seconds(5));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    E_ASSERT((newValue == testResourceOriginalValue));

    delete[] resourceList;
})

/**
 * API under test: Tune
 * - As part of the tune API call, the client specifies the target Logical Cluster and Core, if
 *   the resource in question has Core Level Conflict.
 * - For such a Resource (part of the Request), Core / Cluster Logical To Physical Translation is
 *   needed.
 * - If the logical Core / Cluster value is invalid, or if translation cannot be performed then the
 *   Request is dropped.
 * - Here, we setup the values of logical Core and Cluster such that the Translation will fail.
 * - Verify that the Resource Node's value remains unchanged.
 * Cross-Reference id: [G]
 */
URM_TEST(ResourceLogicalToPhysicalTranslationVerification4, {
    std::string testResourceName = "/etc/urm/tests/nodes/target_test_resource2.txt";
    int32_t testResourceOriginalValue = 333;

    std::string value;
    int32_t originalValue, newValue;

    value = AuxRoutines::readFromFile(testResourceName);
    originalValue = C_STOI(value);
    E_ASSERT((originalValue == testResourceOriginalValue));

    SysResource* resourceList = new SysResource[1];
    memset(&resourceList[0], 0, sizeof(SysResource));
    resourceList[0].mResCode = CONSTRUCT_RES_CODE(0xff, 0x0005);
    resourceList[0].mNumValues = 1;
    resourceList[0].mResValue.value = 2300;
    resourceList[0].mResInfo = 0;

    // Invalid Translation
    resourceList[0].mResInfo = SET_RESOURCE_CLUSTER_VALUE(resourceList[0].mResInfo, 1);
    resourceList[0].mResInfo = SET_RESOURCE_CORE_VALUE(resourceList[0].mResInfo, 87);

    int64_t handle = tuneResources(-1, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

    std::this_thread::sleep_for(std::chrono::seconds(2));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    E_ASSERT((newValue == testResourceOriginalValue));

    delete[] resourceList;
})

/**
 * API under test: Tune
 * - As part of the Config, a Resource can specify a "supported" bit, which indicates
 *   If Tuning is allowed for that Resource
 * - If a Request tries to tune a Resource with the supported bit set to false, then the
 * - the Request should be dropped.
 * - Verify that the Resource Node's value remains unchanged.
 * Cross-Reference id: [H]
 */
URM_TEST(UnSupportedResourceTuningVerification, {
    std::string testResourceName = "/etc/urm/tests/nodes/target_test_resource4.txt";
    int32_t testResourceOriginalValue = 516;

    std::string value;
    int32_t originalValue, newValue;

    value = AuxRoutines::readFromFile(testResourceName);
    originalValue = C_STOI(value);
    E_ASSERT((originalValue == testResourceOriginalValue));

    SysResource* resourceList = new SysResource[1];
    memset(&resourceList[0], 0, sizeof(SysResource));
    resourceList[0].mResCode = CONSTRUCT_RES_CODE(0xff, 0x0007);
    resourceList[0].mNumValues = 1;
    resourceList[0].mResValue.value = 653;

    int64_t handle = tuneResources(-1, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

    std::this_thread::sleep_for(std::chrono::seconds(2));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    E_ASSERT((newValue == testResourceOriginalValue));

    delete[] resourceList;
})

/**
 * API under test: Tune
 * - The Client issues a Tune Request for a Resource which supports Processing in Display Off mode only
 * - However, the current System mode is Display On. In this case, the Configured value for the Resource
 *   as part of the API call should not take effect on the Sysfs Node.
 * - Verify that the Resource Node's value remains unchanged.
 *  Cross-Reference id: [I]
 */
URM_TEST(ResourceOperationModeVerification, {
    std::string testResourceName = "/etc/urm/tests/nodes/target_test_resource3.txt";
    int32_t testResourceOriginalValue = 4400;

    std::string value;
    int32_t originalValue, newValue;

    value = AuxRoutines::readFromFile(testResourceName);
    originalValue = C_STOI(value);
    E_ASSERT((originalValue == testResourceOriginalValue));

    SysResource* resourceList = new SysResource[1];
    memset(&resourceList[0], 0, sizeof(SysResource));
    resourceList[0].mResCode = CONSTRUCT_RES_CODE(0xff, 0x0006);
    resourceList[0].mNumValues = 1;
    resourceList[0].mResValue.value = 4670;

    int64_t handle = tuneResources(-1, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

    std::this_thread::sleep_for(std::chrono::seconds(2));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    E_ASSERT((newValue == testResourceOriginalValue));

    delete[] resourceList;
})

/**
 * API under test: Tune
 * - A client sends a Resource(s) Provisioning Request to tune a resource for some (possibly inf) duration
 * - The resource in question has a "higher_is_better" policy.
 * - Each Resource has an associated permission, either system or third_party. Here the
 *   resource in question has system Permissions i.e. only Clients having system permissions
 *   can tune the resource.
 * - The client here only has third_party permissions, hence the request should be rejected
 *   by the Verifier
 * - Verify that the Resource Node's value remains unchanged.
 * Cross-Reference id: [J]
 */
URM_TEST(ClientPermissionsVerification, {

    std::string testResourceName = "/etc/urm/tests/nodes/target_test_resource1.txt";
    int32_t testResourceOriginalValue = 240;

    std::string value;
    int32_t originalValue, newValue;

    value = AuxRoutines::readFromFile(testResourceName);
    originalValue = C_STOI(value);
    E_ASSERT((originalValue == testResourceOriginalValue));

    SysResource* resourceList = new SysResource[1];
    memset(&resourceList[0], 0, sizeof(SysResource));
    resourceList[0].mResCode = CONSTRUCT_RES_CODE(0xff, 0x0004);
    resourceList[0].mNumValues = 1;
    resourceList[0].mResValue.value = 460;

    int64_t handle = tuneResources(-1, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

    std::this_thread::sleep_for(std::chrono::seconds(2));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    E_ASSERT((newValue == testResourceOriginalValue));

    delete[] resourceList;
})

/*
 * Description:
 * This Section contains tests which aim to verify the correctness of the Verifier.
 * The Verifier is responsible for validating the Tune Request on various param before
 * handing it to the RequestQueue for application. Specifically it checks the following params:
 * - Request Level Tests
 *   - Sanity Tests
 *       - Request should have a positive duration (with the exception of -1) [A]
 *       - Request should specify a non-zero number of Resources to Tune [B]
 *       - Request should have a valid Priority i.e. either HIGH (0) or LOW (1) [D]
 * - Resource Level Tests
 *   - Verifier will iterate over all the Resources part of the Request, and perform the following
 *     tests on each of them. Note if any test fails for any (even one) Resource part of the Request,
 *     then the entire Request shall be dropped.
 *   - Sanity Tests
 *       - Each Resource with the specified ID should exist in the Resource Registry [E]
 *   - Application Tests
 *       - The configured value for the Resource should be in the Range LT, HT as specified by the
 *         Resource Config [F]
 *       - If the Resource has a core level conflict, then Logical to Physical Mapping happens
 *         as part of the Verifier, if the translation cannot be performed then the Request is dropped. [G]
 *       - If the Resource does not support tuning, then the Request will be dropped. [H]
 *       - Check if the Resorce can be tuned in the current System mode. Note, each Resource can specify
 *         via Config, the list of Modes (for example: Display On, Doze) it can be tuned in. [I]
 *   - Permission Check:
 *       - Each Resource can specify a permission level, i.e. only the client with Permission level equal
 *         to or greater than what is specified in the Resource Config can tune that Resource. [J]
 * All the above mentioned cases are covered by the different tests under this section.
 * Note: While almost all the Request Verification happens on the Server end, however to save Server
 * Request Processing time, some very basic Request Verification happens on the Client side as well.
 * This includes testing for cases A, B and C.
 */

/**
 * API under test: tuneSignal
 * - The client tries to tune a Signal with a duration of -2.
 * - Note a duration of 0 is considered valid for the tuneSignal API.
 * - The Request will fail reliminary tests on the Client side and won't be
 *   submitted to the Server returning -1 to the End-Client.
 * Cross-Reference id: [A]
 */
URM_TEST(SignalNullOrInvalidRequestVerification, {
    int64_t handle = tuneSignal(1, 0, -2, RequestPriority::REQ_PRIORITY_HIGH, "app-name", "scenario-zip", 0, nullptr);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

    E_ASSERT((handle == RC_REQ_SUBMISSION_FAILURE));
})

/**
 * API under test: tuneSignal
 * - A client sends a Signal Request to tune a Signal for some (possibly inf) duration
 * - Each Signal Config has an associated permission, either system or third_party. Here the
 *   Signal in question has system Permissions i.e. only Clients having system permissions
 *   can tune this signal.
 * - The client here only has third_party permissions, hence the request should be rejected
 *   by the Signal Verifier
 * - Verify that the Resource Node's value remains unchanged.
 * Cross-Reference id: [C]
 */
URM_TEST(SignalClientPermissionChecksVerification, {
    std::string testResourceName = "/etc/urm/tests/nodes/sched_util_clamp_max.txt";
    int32_t testResourceOriginalValue = 684;

    std::string value;
    int32_t originalValue, newValue;

    value = AuxRoutines::readFromFile(testResourceName);
    originalValue = C_STOI(value);
    E_ASSERT((originalValue == testResourceOriginalValue));

    int64_t handle =
        tuneSignal(
            (CONSTRUCT_RES_CODE(0x0001, 0x0d)),
            DEFAULT_SIGNAL_TYPE,
            5000,
            RequestPriority::REQ_PRIORITY_HIGH,
            "app-name",
            "scenario-zip",
            0, nullptr);

    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

    std::this_thread::sleep_for(std::chrono::seconds(2));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    E_ASSERT((newValue == testResourceOriginalValue));
})

/**
 * API under test: tuneSignal
 * - A client sends a Signal Request to Tune a Signal for some (possibly inf) duration
 * - Each Resource associated with the Signal Config has an associated Low Threshold (LT) and High Threshold (HT).
 * - If a Signal Config specifies a value which is (< LT) or (> HT) for any Resource, then the Reuqest
 *   should be rejected by the Signal Verifier
 * - Verify that the Resource Node's value remains unchanged.
 * Cross-Reference id: [D]
 */
URM_TEST(SignalOutOfBoundsResourceTuning, {
    std::string testResourceName = "/etc/urm/tests/nodes/sched_util_clamp_min.txt";
    int32_t testResourceOriginalValue = 300;

    std::string value;
    int32_t originalValue, newValue;

    value = AuxRoutines::readFromFile(testResourceName);
    originalValue = C_STOI(value);
    E_ASSERT((originalValue == testResourceOriginalValue));

    int64_t handle =
        tuneSignal(
            (CONSTRUCT_SIG_CODE(0x0d, 0x0002)),
            DEFAULT_SIGNAL_TYPE,
            5000,
            RequestPriority::REQ_PRIORITY_HIGH,
            "app-name",
            "scenario-zip",
            0, nullptr);

    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

    std::this_thread::sleep_for(std::chrono::seconds(2));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    E_ASSERT((newValue == testResourceOriginalValue));
})

/**
 * API under test: tuneSignal
 * - Through the Signal Configs, it can be specified for each Signal which target it is supported
 *   on and for which it is not eligible for provisioning.
 * - If a client tries to tune a Signal on a Target, where the Signal is not supported, the
 *   request should be rejected by the Signal Verifier.
 * - Verify that the Resource Node's value remains unchanged.
 * - Here the Signal in question is supported on "sun" and "moon", but the client tries to tune it
 *   on Kodiak. Hence, the Request should be dropped.
 * Cross-Reference id: [E]
 */
URM_TEST(SignalTargetCompatabilityVerificationChecks, {
    std::string testResourceName = "/etc/urm/tests/nodes/sched_util_clamp_min.txt";
    int32_t testResourceOriginalValue = 300;

    std::string value;
    int32_t originalValue, newValue;

    value = AuxRoutines::readFromFile(testResourceName);
    originalValue = C_STOI(value);
    E_ASSERT((originalValue == testResourceOriginalValue));

    int64_t handle = tuneSignal(
        (CONSTRUCT_SIG_CODE(0x0d, 0x0000)),
        DEFAULT_SIGNAL_TYPE,
        5000,
        RequestPriority::REQ_PRIORITY_HIGH,
        "app-name",
        "scenario-zip",
        0, nullptr);

    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

    std::this_thread::sleep_for(std::chrono::seconds(2));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    E_ASSERT((newValue == testResourceOriginalValue));
})

/**
 * API under test: tuneSignal
 * - If the Enabled Field for the Signal Config is set to false, the Signal should not be provisioned.
 * - Hence, the Request is rejected by the Signal Verifier.
 * - Verify that the Resource Node's value remains unchanged.
 * Cross-Reference id: [F]
 */
URM_TEST(SignalNonSupportedSignalProvisioningVerification, {
    std::string testResourceName = "/etc/urm/tests/nodes/sched_util_clamp_min.txt";
    int32_t testResourceOriginalValue = 300;

    std::string value;
    int32_t originalValue, newValue;

    value = AuxRoutines::readFromFile(testResourceName);
    originalValue = C_STOI(value);
    E_ASSERT((originalValue == testResourceOriginalValue));

    int64_t handle = tuneSignal(
        (CONSTRUCT_SIG_CODE(0x0d, 0x0003)),
        DEFAULT_SIGNAL_TYPE,
        5000,
        RequestPriority::REQ_PRIORITY_HIGH,
        "app-name",
        "scenario-zip",
        0, nullptr);

    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

    std::this_thread::sleep_for(std::chrono::seconds(2));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    E_ASSERT((newValue == testResourceOriginalValue));
})

/*
 * Description:
 * This Section contains tests which aim to verify the correctness of Request Application.
 * Here the components majorly involved are RequestQueue and CocoTable.
 * The value of the resource Node is updated based on it's policy.
 * The tests in this section aim to verify that the Resource Nodes are updated
 * correctly in accordace with the Policy, in the case of Concurrent Requests for the same Resource.
 * The tests are enumerated as follows:
 * => Single Client - Single Resource Tuning [A]
 * => Single Client - Multiple Resources Tuning [B]
 * => Multiple Clients - Single Resource Tuning
 *   -- Policy: Higher Is Better [C]
 *   -- Polciy: Lower is Better [D]
 *   -- Policy: Lazy Apply [E]
 *   -- Instant Apply [F]
 * => Multiple Clients - Multiple Resources [G]
 * Special Cases:
 *   => Single Client, Multiple Sequential Requests [S1]
 *   => Multiple Client TIDs, Concurrent Requests [S2]
 * Untune Requests Handling
 * => Valid Untuning: Client C1 issued Request H1, and C1 issues an untune for H1 [U1]
 * => Invalid Untuning: Client C1 issue Request H1, however another client C2 tries
 *    to issue an untune for H2 [U2]
 * Priority Acquisition:
 * => Ensure that a Request with higher Priority always takes effect over another
 *    Request trying to provision the same resource, but with a lower Priority. [H]
 * Retune Requests Handling:
 * => Valid Retuning: Client C1 issued Request H1, and C1 issues a Retune for H1 [R1]
 * => Invalid Retuning:
 * - Client tries to reduce Request Duration [R2]
 * - Client C1 issues Request H1, however another client C2 tries to Retune H1 [R3]
 */

/**
 * API under test: Tune / Untune
 * - Try to configure the value for a specific resource Node.
 * - Here we have a single client, hence no concurrency considerations.
 * - Verify that the config takes effect.
 * - Verify that once the Request Expires, the Resource Node value is reset.
 * Cross-Reference id: [A]
 */
URM_TEST(SingleClientTuneRequest, {
    std::string testResourceName = "/etc/urm/tests/nodes/sched_util_clamp_min.txt";
    int32_t testResourceOriginalValue = 300;

    // Check the original value for the Resource
    std::string value = AuxRoutines::readFromFile(testResourceName);
    int32_t originalValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Original Value: "<<originalValue<<std::endl;
    E_ASSERT((originalValue == testResourceOriginalValue));

    SysResource* resourceList = new SysResource[1];
    memset(&resourceList[0], 0, sizeof(SysResource));
    resourceList[0].mResCode = CONSTRUCT_RES_CODE(0xff, 0x0000);
    resourceList[0].mNumValues = 1;
    resourceList[0].mResValue.value = 980;

    int64_t handle = tuneResources(5000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;
    E_ASSERT((handle > 0));

    std::this_thread::sleep_for(std::chrono::seconds(1));

    // Check if the new value was successfully written to the node
    value = AuxRoutines::readFromFile(testResourceName);
    int32_t newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Configured Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == 980));

    std::this_thread::sleep_for(std::chrono::seconds(6));

    // Wait for the Request to expire, check if the value resets
    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    E_ASSERT((newValue == originalValue));

    delete[] resourceList;
})

/**
 * API under test: Tune / Untune
 * - Single Client sends a request to tune multiple resources (3 here).
 * - Here we have a single client, hence no concurrency considerations.
 * - Verify that the supplied valued takes effect on each of the resource nodes.
 * - Verify that once the Request Expires, each of the Resource Node value is reset.
 * Cross-Reference id: [B]
 */
URM_TEST(SingleClientTuneRequestMultipleResources, {
    // Check the original value for each of the Resource
    std::string testResourceName1 = "/etc/urm/tests/nodes/scaling_max_freq.txt";
    std::string testResourceName2 = "/etc/urm/tests/nodes/scaling_min_freq.txt";
    std::string testResourceName3 = "/etc/urm/tests/nodes/sched_util_clamp_max.txt";

    int32_t testResourceOriginalValue1 = 114;
    int32_t testResourceOriginalValue2 = 107;
    int32_t testResourceOriginalValue3 = 684;

    std::string value;
    int32_t originalValue[3], newValue;

    value = AuxRoutines::readFromFile(testResourceName1);
    originalValue[0] = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName1<<" Original Value: "<<originalValue[0]<<std::endl;
    E_ASSERT((originalValue[0] == testResourceOriginalValue1));

    value = AuxRoutines::readFromFile(testResourceName2);
    originalValue[1] = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName2<<" Original Value: "<<originalValue[1]<<std::endl;
    E_ASSERT((originalValue[1] == testResourceOriginalValue2));

    value = AuxRoutines::readFromFile(testResourceName3);
    originalValue[2] = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName3<<" Original Value: "<<originalValue[2]<<std::endl;
    E_ASSERT((originalValue[2] == testResourceOriginalValue3));

    SysResource* resourceList = new SysResource[3];
    memset(&resourceList[0], 0, sizeof(SysResource));
    resourceList[0].mResCode = CONSTRUCT_RES_CODE(0xff, 0x0003);
    resourceList[0].mNumValues = 1;
    resourceList[0].mResValue.value = 765;

    memset(&resourceList[1], 0, sizeof(SysResource));
    resourceList[1].mResCode = CONSTRUCT_RES_CODE(0xff, 0x0001);
    resourceList[1].mNumValues = 1;
    resourceList[1].mResValue.value = 889;

    memset(&resourceList[2], 0, sizeof(SysResource));
    resourceList[2].mResCode = CONSTRUCT_RES_CODE(0xff, 0x0002);
    resourceList[2].mNumValues = 1;
    resourceList[2].mResValue.value = 617;

    int64_t handle = tuneResources(6000, RequestPriority::REQ_PRIORITY_HIGH, 3, resourceList);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;
    E_ASSERT((handle > 0));

    std::this_thread::sleep_for(std::chrono::seconds(1));

    // Check if the new value was successfully written to each of the nodes
    value = AuxRoutines::readFromFile(testResourceName1);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName1<<" Configured Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == 765));

    value = AuxRoutines::readFromFile(testResourceName2);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName2<<" Configured Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == 617));

    value = AuxRoutines::readFromFile(testResourceName3);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName3<<" Configured Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == 889));

    std::this_thread::sleep_for(std::chrono::seconds(6));

    // Wait for the Request to expire, check if the values reset
    value = AuxRoutines::readFromFile(testResourceName1);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName1<<" Reset Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == originalValue[0]));

    value = AuxRoutines::readFromFile(testResourceName2);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName2<<" Reset Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == originalValue[1]));

    value = AuxRoutines::readFromFile(testResourceName3);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName3<<" Reset Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == originalValue[2]));

    std::this_thread::sleep_for(std::chrono::seconds(4));

    delete[] resourceList;
})

/**
 * API under test: Tune / Untune
 * - Two clients send requests for the same resource concurrently.
 * - Verify that the correct values takes effect for the Resource Node.
 * - Here the resource in question has the "Higher-Is-Better" policy, hence the bigger value of
 *   the 2 should take effect.
 * - Verify that once both the Request Expires (Note: Here both the requests have exactly the same duration), the
 *   Resource Node value should be reset.
 * Cross-Reference id: [C]
 */
URM_TEST(TestMultipleClientsHigherIsBetterPolicy1, {
    // Check the original value for the Resource
    std::string testResourceName = "/etc/urm/tests/nodes/scaling_max_freq.txt";
    int32_t testResourceOriginalValue = 114;

    std::string value = AuxRoutines::readFromFile(testResourceName);
    int32_t originalValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Original Value: "<<originalValue<<std::endl;
    E_ASSERT((originalValue == testResourceOriginalValue));

    int32_t rc = fork();
    if(rc == 0) {
        SysResource* resourceList = new SysResource[1];
        memset(&resourceList[0], 0, sizeof(SysResource));
        resourceList[0].mResCode = CONSTRUCT_RES_CODE(0xff, 0x0003);
        resourceList[0].mNumValues = 1;
        resourceList[0].mResValue.value = 315;

        int64_t handle = tuneResources(8000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
        std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

        std::this_thread::sleep_for(std::chrono::seconds(3));
        delete[] resourceList;
        exit(EXIT_SUCCESS);

    } else if(rc > 0) {
        wait(nullptr);

        SysResource* resourceList = new SysResource[1];
        memset(&resourceList[0], 0, sizeof(SysResource));
        resourceList[0].mResCode = CONSTRUCT_RES_CODE(0xff, 0x0003);
        resourceList[0].mNumValues = 1;
        resourceList[0].mResValue.value = 209;

        int64_t handle = tuneResources(8000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
        std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

        std::this_thread::sleep_for(std::chrono::seconds(2));

        // Check if the new value was successfully written to the node
        value = AuxRoutines::readFromFile(testResourceName);
        int32_t newValue = C_STOI(value);
        std::cout<<LOG_BASE<<testResourceName<<" Configured Value: "<<newValue<<std::endl;

        // Note value should be the higher of the 2, since for this resource the
        // policy set is "Higher is Better"
        E_ASSERT((newValue == 315));

        std::this_thread::sleep_for(std::chrono::seconds(8));

        // Wait for the Request to expire, check if the value resets
        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        std::cout<<LOG_BASE<<testResourceName<<" Reset Value: "<<newValue<<std::endl;
        E_ASSERT((newValue == originalValue));

        delete[] resourceList;
    }
})

/**
 * API under test: Tune / Untune
 * - Two clients send requests for Provisioning the same resource concurrently, with different durations
 * - Req1: duration: d1, value: v1
 * - Req2: duration: d2, value: v2
 * - Here the resource in question has the "Higher-Is-Better" policy, hence the bigger value should always take effect
 *   on the node in case of conflicts.
 * - Here d2 > d1 and v1 > v2, both requests are issued concurrently by different processes.
 * - Verify that the correct value takes effect for the Resource Node at different points in time.
 * - From time ~0 to d1, the value v1 (since v1 > v2) should be written to the node, however from time d1 to d2, the value v2 should be written to the node.
 * - Verify that once both the Request Expires (Note: Here both the requests don't have the same duration), the
 *   Resource Node value is reset.
 * Cross-Reference id: [C]
 */
URM_TEST(TestMultipleClientsHigherIsBetterPolicy2, {
    // Check the original value for the Resource
    std::string testResourceName = "/etc/urm/tests/nodes/scaling_max_freq.txt";
    int32_t testResourceOriginalValue = 114;

    std::string value;
    int32_t originalValue, newValue;

    value = AuxRoutines::readFromFile(testResourceName);
    originalValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Original Value: "<<originalValue<<std::endl;
    E_ASSERT((originalValue == testResourceOriginalValue));

    int32_t rc1 = fork();
    if(rc1 == 0) {
        SysResource* resourceList = new SysResource[1];
        memset(&resourceList[0], 0, sizeof(SysResource));
        resourceList[0].mResCode = CONSTRUCT_RES_CODE(0xff, 0x0003);
        resourceList[0].mNumValues = 1;
        resourceList[0].mResValue.value = 1176;

        int64_t handle = tuneResources(8000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
        std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

        std::this_thread::sleep_for(std::chrono::seconds(3));
        delete[] resourceList;
        exit(EXIT_SUCCESS);

    } else if(rc1 > 0) {
        wait(nullptr);
        SysResource* resourceList = new SysResource[1];
        memset(&resourceList[0], 0, sizeof(SysResource));
        resourceList[0].mResCode = CONSTRUCT_RES_CODE(0xff, 0x0003);
        resourceList[0].mNumValues = 1;
        resourceList[0].mResValue.value = 823;

        int64_t handle = tuneResources(14000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
        std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

        std::this_thread::sleep_for(std::chrono::seconds(2));

        // Check if the new value was successfully written to the node
        // The higher value should be written to the node, since the Resource has
        // Higer is better policy
        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        std::cout<<LOG_BASE<<testResourceName<<" Configured Value: "<<newValue<<std::endl;
        E_ASSERT((newValue == 1176));

        std::this_thread::sleep_for(std::chrono::seconds(6));

        // By this time the Request configuring the value of 1176 should have expired
        // And the Pending Request with a configuration value of 823, should take effect.
        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        std::cout<<LOG_BASE<<testResourceName<<" Configured Value: "<<newValue<<std::endl;
        E_ASSERT((newValue == 823));

        std::this_thread::sleep_for(std::chrono::seconds(10));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        std::cout<<LOG_BASE<<testResourceName<<" Reset Value: "<<originalValue<<std::endl;
        E_ASSERT((newValue == originalValue));

        delete[] resourceList;
    }
})

/**
 * API under test: Tune / Untune
 * - Four clients send requests for the same resource concurrently, with the same durations
 * - Req1: duration: d1, value: v1
 * - Req2: duration: d2, value: v2
 *   and similary for other Requests.
 * - d1 = d2 = d3 = d4.
 * - v1 > v2 > v3 > v4
 * - Here the resource in question has the "Lower-Is-Better" policy, hence the smaller value should always take effect
 *   on the node in case of conflicts.
 * - Verify that the correct value takes effect for the Resource Node at different points in time.
 * - Verify that once all the Requests Expires (Note: Here all the requests have exactly the same duration), the
 *   Resource Node value is reset.
 * Cross-Reference id: [D]
 */
URM_TEST(TestMultipleClientsLowerIsBetterPolicy, {
    // Check the original value for the Resource
    std::string testResourceName = "/etc/urm/tests/nodes/scaling_min_freq.txt";
    int32_t testResourceOriginalValue = 107;

    std::string value;
    int32_t originalValue, newValue;

    value = AuxRoutines::readFromFile(testResourceName);
    originalValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Original Value: "<<originalValue<<std::endl;
    E_ASSERT((originalValue == testResourceOriginalValue));

    int64_t handle;

    int32_t rc1 = fork();
    if(rc1 == 0) {
        SysResource* resourceList = new SysResource[1];
        memset(&resourceList[0], 0, sizeof(SysResource));
        resourceList[0].mResCode = CONSTRUCT_RES_CODE(0xff, 0x0002);
        resourceList[0].mNumValues = 1;
        resourceList[0].mResValue.value = 578;

        handle = tuneResources(15000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
        std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

        // Give enough time for Resource Tuner to read process status
        // Else the Request will be dropped
        std::this_thread::sleep_for(std::chrono::seconds(3));
        delete[] resourceList;
        exit(EXIT_SUCCESS);

    } else if(rc1 > 0) {
        wait(nullptr);
        std::this_thread::sleep_for(std::chrono::seconds(1));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        std::cout<<LOG_BASE<<testResourceName<<" Configured Value: "<<newValue<<std::endl;
        E_ASSERT((newValue == 578));

        int32_t rc2 = fork();
        if(rc2 == 0) {
            SysResource* resourceList = new SysResource[1];
            memset(&resourceList[0], 0, sizeof(SysResource));
            resourceList[0].mResCode = CONSTRUCT_RES_CODE(0xff, 0x0002);
            resourceList[0].mNumValues = 1;
            resourceList[0].mResValue.value = 445;

            handle = tuneResources(15000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
            std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

            std::this_thread::sleep_for(std::chrono::seconds(3));
            delete[] resourceList;
            exit(EXIT_SUCCESS);

        } else if(rc2 > 0) {
            wait(nullptr);
            std::this_thread::sleep_for(std::chrono::seconds(1));

            value = AuxRoutines::readFromFile(testResourceName);
            newValue = C_STOI(value);
            std::cout<<LOG_BASE<<testResourceName<<" Configured Value: "<<newValue<<std::endl;
            E_ASSERT((newValue == 445));

            int32_t rc3 = fork();
            if(rc3 == 0) {
                SysResource* resourceList = new SysResource[1];
                memset(&resourceList[0], 0, sizeof(SysResource));
                resourceList[0].mResCode = CONSTRUCT_RES_CODE(0xff, 0x0002);
                resourceList[0].mNumValues = 1;
                resourceList[0].mResValue.value = 412;

                handle = tuneResources(15000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
                std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

                std::this_thread::sleep_for(std::chrono::seconds(3));
                delete[] resourceList;
                exit(EXIT_SUCCESS);

            } else if(rc3 > 0) {
                wait(nullptr);
                std::this_thread::sleep_for(std::chrono::seconds(1));

                value = AuxRoutines::readFromFile(testResourceName);
                newValue = C_STOI(value);
                std::cout<<LOG_BASE<<testResourceName<<" Configured Value: "<<newValue<<std::endl;
                E_ASSERT((newValue == 412));

                SysResource* resourceList = new SysResource[1];
                memset(&resourceList[0], 0, sizeof(SysResource));
                resourceList[0].mResCode = CONSTRUCT_RES_CODE(0xff, 0x0002);
                resourceList[0].mNumValues = 1;
                resourceList[0].mResValue.value = 378;

                handle = tuneResources(15000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
                std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

                std::this_thread::sleep_for(std::chrono::seconds(1));

                value = AuxRoutines::readFromFile(testResourceName);
                newValue = C_STOI(value);
                std::cout<<LOG_BASE<<testResourceName<<" Configured Value: "<<newValue<<std::endl;
                E_ASSERT((newValue == 378));

                std::this_thread::sleep_for(std::chrono::seconds(30));

                value = AuxRoutines::readFromFile(testResourceName);
                newValue = C_STOI(value);
                std::cout<<LOG_BASE<<testResourceName<<" Reset Value: "<<newValue<<std::endl;
                E_ASSERT((newValue == originalValue));

                delete[] resourceList;
            }
        }
    }
})

/**
 * API under test: Tune / Untune
 * - Two clients send requests for the same resource concurrently, with different durations
 * - Req1: duration: d1, value: v1
 * - Req2: duration: d2, value: v2
 * - Here the resource in question has the "Lazy-Apply" policy, hence the Request should take
 * - effect in a "First-In First-Out (FIFO)" manner.
 * - Verify that the correct value takes effect for the Resource Node at different points in time.
 * - Verify that once all the Requests Expires, the Resource Node value is reset.
 * Cross-Reference id: ['E']
 */
URM_TEST(TestMultipleClientsLazyApplyPolicy, {
    std::string testResourceName = "/etc/urm/tests/nodes/target_test_resource5.txt";
    int32_t testResourceOriginalValue = 17;

    std::string value;
    int32_t originalValue, newValue;

    value = AuxRoutines::readFromFile(testResourceName);
    originalValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Original Value: "<<originalValue<<std::endl;
    E_ASSERT((originalValue == testResourceOriginalValue));

    int64_t handle;
    int32_t rc1 = fork();
    if(rc1 == 0) {
        SysResource* resourceList = new SysResource[1];
        memset(&resourceList[0], 0, sizeof(SysResource));
        resourceList[0].mResCode = CONSTRUCT_RES_CODE(0xff, 0x0008);
        resourceList[0].mNumValues = 1;
        resourceList[0].mResValue.value = 15;

        handle = tuneResources(12000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
        std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

        std::this_thread::sleep_for(std::chrono::seconds(3));
        delete[] resourceList;
        exit(EXIT_SUCCESS);

    } else if(rc1 > 0) {
        wait(nullptr);
        std::this_thread::sleep_for(std::chrono::seconds(1));

        SysResource* resourceList = new SysResource[1];
        memset(&resourceList[0], 0, sizeof(SysResource));
        resourceList[0].mResCode = CONSTRUCT_RES_CODE(0xff, 0x0008);
        resourceList[0].mNumValues = 1;
        resourceList[0].mResValue.value = 18;

        handle = tuneResources(15000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
        std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

        std::this_thread::sleep_for(std::chrono::seconds(1));

        // The new Value should be valid for 8 seconds
        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        std::cout<<LOG_BASE<<testResourceName<<" Configured Value: "<<newValue<<std::endl;
        E_ASSERT((newValue == 15));

        std::this_thread::sleep_for(std::chrono::seconds(3));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        std::cout<<LOG_BASE<<testResourceName<<" Configured Value: "<<newValue<<std::endl;
        E_ASSERT((newValue == 15));

        std::this_thread::sleep_for(std::chrono::seconds(8));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        std::cout<<LOG_BASE<<testResourceName<<" Configured Value: "<<newValue<<std::endl;
        E_ASSERT((newValue == 18));

        std::this_thread::sleep_for(std::chrono::seconds(12));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        std::cout<<LOG_BASE<<testResourceName<<" Reset Value: "<<newValue<<std::endl;
        E_ASSERT((newValue == originalValue));

        delete[] resourceList;
    }
})

/**
 * API under test: Tune / Untune
 * - Three clients send requests for three different resources concurrently, with the same duration
 * - Here the Requests are for separate resources, hence no concurrency considerations at Resource Level
 * - Verify that the supplied value takes effect for each of the Resource Nodes (Note, all the Requests are designed to be valid).
 * - Verify that each of the request expires, the corresponding Resource Node's value is reset
 * - Cross-Reference id: ['G']
 */
URM_TEST(TestMultipleClientsTuneRequestDifferentResources, {
    // Check the original value for the Resource
    std::string testResourceName1 = "/etc/urm/tests/nodes/scaling_min_freq.txt";
    std::string testResourceName2 = "/etc/urm/tests/nodes/scaling_max_freq.txt";
    std::string testResourceName3 = "/etc/urm/tests/nodes/sched_util_clamp_max.txt";

    int32_t testResourceOriginalValue1 = 107;
    int32_t testResourceOriginalValue2 = 114;
    int32_t testResourceOriginalValue3 = 684;

    std::string value;
    int32_t originalValue, newValue;

    value = AuxRoutines::readFromFile(testResourceName1);
    originalValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName1<<" Original Value: "<<originalValue<<std::endl;
    E_ASSERT((originalValue == testResourceOriginalValue1));

    value = AuxRoutines::readFromFile(testResourceName2);
    originalValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName2<<" Original Value: "<<originalValue<<std::endl;
    E_ASSERT((originalValue == testResourceOriginalValue2));

    value = AuxRoutines::readFromFile(testResourceName3);
    originalValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceOriginalValue3<<" Original Value: "<<originalValue<<std::endl;
    E_ASSERT((originalValue == testResourceOriginalValue3));

    int32_t rc1 = fork();
    if(rc1 == 0) {
        SysResource* resourceList = new SysResource[1];
        memset(&resourceList[0], 0, sizeof(SysResource));
        resourceList[0].mResCode = CONSTRUCT_RES_CODE(0xff, 0x0002);
        resourceList[0].mNumValues = 1;
        resourceList[0].mResValue.value = 717;

        int64_t handle = tuneResources(18000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
        std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

        std::this_thread::sleep_for(std::chrono::seconds(3));
        delete[] resourceList;
        exit(EXIT_SUCCESS);

    } else if(rc1 > 0) {
        int32_t rc2 = fork();
        if(rc2 == 0) {
            SysResource* resourceList = new SysResource[1];
            memset(&resourceList[0], 0, sizeof(SysResource));
            resourceList[0].mResCode = CONSTRUCT_RES_CODE(0xff, 0X0003);
            resourceList[0].mNumValues = 1;
            resourceList[0].mResValue.value = 800;

            int64_t handle = tuneResources(18000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
            std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

            std::this_thread::sleep_for(std::chrono::seconds(3));
            delete[] resourceList;
            exit(EXIT_SUCCESS);

        } else if(rc2 > 0) {
            SysResource* resourceList = new SysResource[1];
            memset(&resourceList[0], 0, sizeof(SysResource));
            resourceList[0].mResCode = CONSTRUCT_RES_CODE(0xff, 0x0001);
            resourceList[0].mNumValues = 1;
            resourceList[0].mResValue.value = 557;

            int64_t handle = tuneResources(18000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
            std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

            std::this_thread::sleep_for(std::chrono::seconds(4));

            // Check if the new value was successfully written to the node
            value = AuxRoutines::readFromFile(testResourceName1);
            newValue = C_STOI(value);
            std::cout<<LOG_BASE<<testResourceName1<<" Configured Value: "<<newValue<<std::endl;
            E_ASSERT((newValue == 717));

            value = AuxRoutines::readFromFile(testResourceName2);
            newValue = C_STOI(value);
            std::cout<<LOG_BASE<<testResourceName2<<" Configured Value: "<<newValue<<std::endl;
            E_ASSERT((newValue == 800));

            value = AuxRoutines::readFromFile(testResourceName3);
            newValue = C_STOI(value);
            std::cout<<LOG_BASE<<testResourceName3<<" Configured Value: "<<newValue<<std::endl;
            E_ASSERT((newValue == 557));

            // Wait for the Nodes to Reset
            std::this_thread::sleep_for(std::chrono::seconds(20));

            value = AuxRoutines::readFromFile(testResourceName1);
            originalValue = C_STOI(value);
            std::cout<<LOG_BASE<<testResourceName1<<" Reset Value: "<<originalValue<<std::endl;
            E_ASSERT((originalValue == testResourceOriginalValue1));

            value = AuxRoutines::readFromFile(testResourceName2);
            originalValue = C_STOI(value);
            std::cout<<LOG_BASE<<testResourceName2<<" Reset Value: "<<originalValue<<std::endl;
            E_ASSERT((originalValue == testResourceOriginalValue2));

            value = AuxRoutines::readFromFile(testResourceName3);
            originalValue = C_STOI(value);
            std::cout<<LOG_BASE<<testResourceName3<<" Reset Value: "<<originalValue<<std::endl;
            E_ASSERT((originalValue == testResourceOriginalValue3));

            waitpid(rc1, nullptr, 0);
            waitpid(rc2, nullptr, 0);

            delete[] resourceList;
        }
    }
})

/**
 * API under test: Tune / Untune
 * - Single Client sends multiple requests sequentially to tune the same resource.
 * - The resource in question has a "high_is_better" policy.
 * - Verify that the higher of the two supplied valued takes effect on the resource node.
 * - Verify that once the Request Expires, the Resource Node's value is reset.
 * Cross-Reference id: ['S1']
 */
URM_TEST(SingleClientSequentialRequests, {
    std::string testResourceName = "/etc/urm/tests/nodes/scaling_max_freq.txt";
    int32_t testResourceOriginalValue = 114;
    int64_t handle;

    std::string value;
    int32_t originalValue, newValue;

    value = AuxRoutines::readFromFile(testResourceName);
    originalValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Original Value: "<<originalValue<<std::endl;
    E_ASSERT((originalValue == testResourceOriginalValue));

    SysResource* resourceList1 = new SysResource[1];
    memset(&resourceList1[0], 0, sizeof(SysResource));
    resourceList1[0].mResCode = CONSTRUCT_RES_CODE(0xff, 0x0003);
    resourceList1[0].mNumValues = 1;
    resourceList1[0].mResValue.value = 889;

    SysResource* resourceList2 = new SysResource[1];
    memset(&resourceList2[0], 0, sizeof(SysResource));
    resourceList2[0].mResCode = CONSTRUCT_RES_CODE(0xff, 0x0003);
    resourceList2[0].mNumValues = 1;
    resourceList2[0].mResValue.value = 917;

    handle = tuneResources(6000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList1);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

    handle = tuneResources(6000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList2);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

    std::this_thread::sleep_for(std::chrono::seconds(2));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Configured Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == 917));

    std::this_thread::sleep_for(std::chrono::seconds(6));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Reset Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == testResourceOriginalValue));

    delete[] resourceList1;
    delete[] resourceList2;
})

/**
 * API under test: Tune / Untune
 * - Two threads of the same Client process send requests concurrently to tune the same resource.
 * - The resource in question has a "high_is_better" policy.
 * - Verify that the higher of the two supplied valued takes effect on the resource node.
 * - Verify that once the Request Expires, the Resource Node's value is reset.
 * - Note, only a single thread can send a message over the Socket at once, the other thread will
 * - be blocked until the first thread is done.
 * Cross-Reference id: ['S2']
 */
URM_TEST(MultipleClientTIDsConcurrentRequests, {
    std::string testResourceName = "/etc/urm/tests/nodes/scaling_max_freq.txt";
    int32_t testResourceOriginalValue = 114;
    int64_t handle;

    std::string value;
    int32_t originalValue, newValue;

    value = AuxRoutines::readFromFile(testResourceName);
    originalValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Original Value: "<<originalValue<<std::endl;
    E_ASSERT((originalValue == testResourceOriginalValue));

    std::thread th([&]{
        SysResource* resourceList1 = new SysResource[1];
        memset(&resourceList1[0], 0, sizeof(SysResource));
        resourceList1[0].mResCode = CONSTRUCT_RES_CODE(0xff, 0x0003);
        resourceList1[0].mOptionalInfo = 0;
        resourceList1[0].mNumValues = 1;
        resourceList1[0].mResValue.value = 664;

        handle = tuneResources(6000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList1);
        std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

        delete[] resourceList1;
    });

    SysResource* resourceList2 = new SysResource[1];
    memset(&resourceList2[0], 0, sizeof(SysResource));
    resourceList2[0].mResCode = CONSTRUCT_RES_CODE(0xff, 0x0003);
    resourceList2[0].mOptionalInfo = 0;
    resourceList2[0].mNumValues = 1;
    resourceList2[0].mResValue.value = 702;

    handle = tuneResources(6000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList2);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

    std::this_thread::sleep_for(std::chrono::seconds(2));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Configured Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == 702));

    std::this_thread::sleep_for(std::chrono::seconds(6));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Reset Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == testResourceOriginalValue));

    th.join();

    delete[] resourceList2;
})

/**
 * API under test: Tune / Untune
 * - A client sends a Resource(s) Provisioning Request to tune a resource for an infinite (-1) duration
 * - The resource in question has a "lower_is_better" policy.
 * - Verify that the supplied valued takes effect on the resource node.
 * - Send an untune request from the client.
 * - Verify that the Resource Node's value is reset.
 * - Note only the client which issued the Tune request can issue a corresponding Untune
 *   Request for the same Handle.
 * Cross-Reference id: ['U1']
 */
URM_TEST(TestInfiniteDurationTuneRequestAndValidUntuning, {
    std::string testResourceName = "/etc/urm/tests/nodes/scaling_min_freq.txt";
    int32_t testResourceOriginalValue = 107;
    int64_t handle;

    std::string value;
    int32_t originalValue, newValue;

    value = AuxRoutines::readFromFile(testResourceName);
    originalValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Original Value: "<<originalValue<<std::endl;
    E_ASSERT((originalValue == testResourceOriginalValue));

    SysResource* resourceList = new SysResource[1];
    SysResource resource;
    memset(&resource, 0, sizeof(SysResource));
    resource.mResCode = CONSTRUCT_RES_CODE(0xff, 0x0002);
    resource.mNumValues = 1;
    resource.mResValue.value = 245;
    resourceList[0] = resource;

    handle = tuneResources(-1, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

    std::this_thread::sleep_for(std::chrono::seconds(2));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Configured Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == 245));

    int8_t status = untuneResources(handle);
    std::cout<<LOG_BASE<<" Untune Status: "<<(int32_t)status<<std::endl;
    E_ASSERT((status == 0));

    std::this_thread::sleep_for(std::chrono::seconds(2));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Untuned Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == testResourceOriginalValue));

    delete[] resourceList;
})

/**
 * API under test: Tune / Untune
 * - A client (X) sends a Resource(s) Provisioning Request to tune a resource for an infinite (-1) duration
 * - The resource in question has a "lower_is_better" policy.
 * - Verify that the supplied valued takes effect on the resource node.
 * - Send an untune request from another client (Y).
 * - Verify that the Resource Node's value is not reset.
 * - Note only the client which issued the Tune request can issue a corresponding Untune
 *   Request for the same Handle.
 * - Now send an Untune request from Client X, and verify that the Resource Node's value
 *   is indeed reset.
 * Cross-Reference id: ['U2']
 */
URM_TEST(TestInfiniteDurationTuneRequestAndInValidUntuning, {
    std::string testResourceName = "/etc/urm/tests/nodes/scaling_min_freq.txt";
    int32_t testResourceOriginalValue = 107;
    int64_t handle;

    std::string value;
    int32_t originalValue, newValue;

    value = AuxRoutines::readFromFile(testResourceName);
    originalValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Original Value: "<<originalValue<<std::endl;
    E_ASSERT((originalValue == testResourceOriginalValue));

    SysResource* resourceList = new SysResource[1];
    memset(&resourceList[0], 0, sizeof(SysResource));
    resourceList[0].mResCode = CONSTRUCT_RES_CODE(0xff, 0x0002);
    resourceList[0].mNumValues = 1;
    resourceList[0].mResValue.value = 245;

    handle = tuneResources(-1, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

    std::this_thread::sleep_for(std::chrono::seconds(2));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Configured Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == 245));

    int32_t rc = fork();
    if(rc == 0) {
        // Child Process
        (void)untuneResources(handle);

        exit(EXIT_SUCCESS);

    } else if(rc > 0) {
        wait(nullptr);

        std::this_thread::sleep_for(std::chrono::seconds(2));

        // Verify that there is no change in value
        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        std::cout<<LOG_BASE<<testResourceName<<" Untuned Value: "<<newValue<<std::endl;
        E_ASSERT((newValue == 245));

        int8_t status = untuneResources(handle);
        std::cout<<LOG_BASE<<"Untune Status: "<<(int32_t)status<<std::endl;
        E_ASSERT((status == 0));

        std::this_thread::sleep_for(std::chrono::seconds(2));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        std::cout<<LOG_BASE<<testResourceName<<" Reset Value: "<<newValue<<std::endl;
        E_ASSERT((newValue == testResourceOriginalValue));

        delete[] resourceList;
    }
})

/**
 * API under test: Tune / Untune
 * - The CocoTable structure is built to handle 4 levels of Priority. A request with
 *   higher priority should take precedence over another with lower priority.
 * - This notion should reflect with respect to Resource Tuning as well, i.e. if there
 *   are 2 valid Requests:
 *   R1, with Priority P1 trying to configure a value of V1 for Resource X
 *   R2, with Priority P2 trying to configure a value of V2 for Resource X
 *   Where, P1 > P1, then the value V1 should take effect on the Resource Sysfs Node
 *   rather than the value V2.
 * - In this case both Requests are sent by the same Client
 * - Verify that the Correct Value takes affect on the Sysfs Nodes
 * - Verify that the Sysfs Node is reset, once the Request Expires
 * Cross-Reference id: ['H']
 */
URM_TEST(TestPriorityBasedResourceAcquisition1, {
    std::string testResourceName = "/etc/urm/tests/nodes/scaling_min_freq.txt";
    int32_t testResourceOriginalValue = 107;
    int64_t handle;

    std::string value;
    int32_t originalValue, newValue;

    value = AuxRoutines::readFromFile(testResourceName);
    originalValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Original Value: "<<originalValue<<std::endl;
    E_ASSERT((originalValue == testResourceOriginalValue));

    SysResource* resourceList1 = new SysResource[1];
    memset(&resourceList1[0], 0, sizeof(SysResource));
    resourceList1[0].mResCode = CONSTRUCT_RES_CODE(0xff, 0x0002);
    resourceList1[0].mNumValues = 1;
    resourceList1[0].mResValue.value = 515;

    handle = tuneResources(8000, RequestPriority::REQ_PRIORITY_LOW, 1, resourceList1);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

    SysResource* resourceList2 = new SysResource[1];
    memset(&resourceList2[0], 0, sizeof(SysResource));
    resourceList2[0].mResCode = CONSTRUCT_RES_CODE(0xff, 0x0002);
    resourceList2[0].mNumValues = 1;
    resourceList2[0].mResValue.value = 559;

    handle = tuneResources(8000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList2);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

    std::this_thread::sleep_for(std::chrono::seconds(2));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Configured Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == 559));

    std::this_thread::sleep_for(std::chrono::seconds(10));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Reset Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == testResourceOriginalValue));

    delete[] resourceList1;
    delete[] resourceList2;
})

/**
 * API under test: Tune / Untune
 * - The CocoTable structure is built to handle 4 levels of Priority. A request with
 *   higher priority should take precedence over another with lower priority.
 * - This notion should reflect with respect to Resource Tuning as well, i.e. if there
 *   are 2 valid Requests:
 *   R1, with Priority P1 trying to configure a value of V1 for Resource X
 *   R2, with Priority P2 trying to configure a value of V2 for Resource X
 *   Where, P1 > P1, then the value V1 should take effect on the Resource Sysfs Node
 *   rather than the value V2.
 * - The Resource in Question here has a "lower_is_better" policy.
 * - In this case both Requests are sent by the same Client within an interval of 5 seconds
 * - i.e. R2 will be sent at time t and R1 at time t + 5
 * - Verify that the Correct Value takes affect on the Sysfs Nodes, i.e. from time
 *   [t, t + 5) the value on the Node should be V2, following which the value V1 should
 *   take effect (as the Request with Higher Priority will be submitted).
 * - Verify that the Sysfs Node is reset, once the Request Expires.
 * Cross-Reference id: ['H']
 */
URM_TEST(PriorityBasedResourceAcquisition2, {
    std::string testResourceName = "/etc/urm/tests/nodes/scaling_min_freq.txt";
    int32_t testResourceOriginalValue = 107;
    int64_t handle;

    std::string value;
    int32_t originalValue, newValue;

    value = AuxRoutines::readFromFile(testResourceName);
    originalValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Original Value: "<<originalValue<<std::endl;
    E_ASSERT((originalValue == testResourceOriginalValue));

    SysResource* resourceList1 = new SysResource[1];
    memset(&resourceList1[0], 0, sizeof(SysResource));
    resourceList1[0].mResCode = CONSTRUCT_RES_CODE(0xff, 0x0002);
    resourceList1[0].mNumValues = 1;
    resourceList1[0].mResValue.value = 515;

    handle = tuneResources(12000, RequestPriority::REQ_PRIORITY_LOW, 1, resourceList1);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

    std::this_thread::sleep_for(std::chrono::seconds(2));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Configured Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == 515));

    std::this_thread::sleep_for(std::chrono::seconds(3));

    SysResource* resourceList2 = new SysResource[1];
    memset(&resourceList2[0], 0, sizeof(SysResource));
    resourceList2[0].mResCode = CONSTRUCT_RES_CODE(0xff, 0x0002);
    resourceList2[0].mNumValues = 1;
    resourceList2[0].mResValue.value = 559;

    handle = tuneResources(8000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList2);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

    std::this_thread::sleep_for(std::chrono::seconds(2));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Configured Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == 559));

    std::this_thread::sleep_for(std::chrono::seconds(10));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Reset Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == testResourceOriginalValue));

    delete[] resourceList1;
    delete[] resourceList2;
})

/**
 * API under test: Tune / Untune
 * - The CocoTable structure is built to handle 4 levels of Priority. A request with
 *   higher priority should take precedence over another with lower priority.
 * - This notion should reflect with respect to Resource Tuning as well, i.e. if there
 *   are 2 valid Requests:
 *   R1, with Priority P1 trying to configure a value of V1 for Resource X
 *   R2, with Priority P2 trying to configure a value of V2 for Resource X
 *   Where, P1 > P2, and V1 < V2
 * - Here the Resource in Question has a "higher_is_better" policy.
 * - At time t = 0 seconds, Request R1 arrives, since there are no other Requests, it should
     immediately take effect.
 * - At time t = 5 seconds, Request R2 arrives, since V2 > V1, in normal conditions, V2 should
 *   be applied to the Resource Node.
 * - However, since P1 > P2, hence V1 will continue to remain applied ahead of V2.
 * - Verify that the Resource Node is reset once the Requests expire
 * Cross-Reference id: ['H']
 */
URM_TEST(TestPriorityBasedResourceAcquisition3, {
    std::string testResourceName = "/etc/urm/tests/nodes/scaling_max_freq.txt";
    int32_t testResourceOriginalValue = 114;
    int64_t handle;

    std::string value;
    int32_t originalValue, newValue;

    value = AuxRoutines::readFromFile(testResourceName);
    originalValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Original Value: "<<originalValue<<std::endl;
    E_ASSERT((originalValue == testResourceOriginalValue));

    SysResource* resourceList1 = new SysResource[1];
    memset(&resourceList1[0], 0, sizeof(SysResource));
    resourceList1[0].mResCode = CONSTRUCT_RES_CODE(0xff, 0x0003);
    resourceList1[0].mOptionalInfo = 0;
    resourceList1[0].mNumValues = 1;
    resourceList1[0].mResValue.value = 645;

    handle = tuneResources(10000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList1);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

    std::this_thread::sleep_for(std::chrono::seconds(2));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Configured Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == 645));

    std::this_thread::sleep_for(std::chrono::seconds(1));

    SysResource* resourceList2 = new SysResource[1];
    memset(&resourceList2[0], 0, sizeof(SysResource));
    resourceList2[0].mResCode = CONSTRUCT_RES_CODE(0xff, 0x0003);
    resourceList2[0].mNumValues = 1;
    resourceList2[0].mResValue.value = 716;

    handle = tuneResources(5000, RequestPriority::REQ_PRIORITY_LOW, 1, resourceList2);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

    std::this_thread::sleep_for(std::chrono::seconds(2));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Configured Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == 645));

    std::this_thread::sleep_for(std::chrono::seconds(10));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Reset Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == testResourceOriginalValue));

    delete[] resourceList1;
    delete[] resourceList2;
})

/**
 * API under test: Retune
 * - Client can use the Retune API to extend the duration of a previously issued Tune Request.
 * - Note only the client which issue the Tune Request with H1, can issue a Retune API for H1.
 * - Here the issues a Tune Request for 8 seconds, however later Retunes it to 15 seconds.
 * - Verify that the Configured values is applied to the Resource Node for this entire duration, i.e. till
 *   15 seconds from the point of issuing the Retune Request.
 * - Note, Retune API only supports extending the duration of a Request and not decreasing it.
 * Cross-Reference id: ['R1']
 */
URM_TEST(TestRequestValidRetuning, {
    std::string testResourceName = "/etc/urm/tests/nodes/scaling_max_freq.txt";
    int32_t testResourceOriginalValue = 114;
    int64_t handle;

    std::string value;
    int32_t originalValue, newValue;

    value = AuxRoutines::readFromFile(testResourceName);
    originalValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Original Value: "<<originalValue<<std::endl;
    E_ASSERT((originalValue == testResourceOriginalValue));

    SysResource* resourceList = new SysResource[1];
    memset(&resourceList[0], 0, sizeof(SysResource));
    resourceList[0].mResCode = CONSTRUCT_RES_CODE(0xff, 0x0003);
    resourceList[0].mNumValues = 1;
    resourceList[0].mResValue.value = 778;

    handle = tuneResources(8000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

    std::this_thread::sleep_for(std::chrono::seconds(4));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Configured Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == 778));

    // Wait for 10 seconds and check the Sysfs Node value
    // The Request will expire in 4 seconds, hence the value should reset to original value
    // However we issue an Untune Request for this handle, and change the duration to 15 seconds
    // Hence when we check the value after 10 seconds, it should still be 778
    int8_t status = retuneResources(handle, 15000);
    std::cout<<LOG_BASE<<"Retune Status: "<<(int32_t)status<<std::endl;
    E_ASSERT((status == 0));

    std::this_thread::sleep_for(std::chrono::seconds(10));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Configured Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == 778));

    std::this_thread::sleep_for(std::chrono::seconds(10));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Reset Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == testResourceOriginalValue));

    delete[] resourceList;
})

/**
 * API under test: Retune
 * - Client can use the Retune API to extend the duration of a previously issued Tune Request.
 * - Note only the client which issue the Tune Request with H1, can issue a Retune API for H1.
 * - Retune API only supports extending the duration of a Request and not decreasing it.
 * - Here the Client issues a Tune Request for 12 seconds, and later tries to Retune it to 6 seconds.
 * - Since the Retune API does not support decreasing Request Duration, hence this Retune Request
 *   should be rejected.
 * Cross-Reference id: ['R2']
 */
URM_TEST(TestRequestInvalidRetuning1, {
    std::string testResourceName = "/etc/urm/tests/nodes/scaling_max_freq.txt";
    int32_t testResourceOriginalValue = 114;
    int64_t handle;

    std::string value;
    int32_t originalValue, newValue;

    value = AuxRoutines::readFromFile(testResourceName);
    originalValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Original Value: "<<originalValue<<std::endl;
    E_ASSERT((originalValue == testResourceOriginalValue));

    SysResource* resourceList = new SysResource[1];
    memset(&resourceList[0], 0, sizeof(SysResource));
    resourceList[0].mResCode = CONSTRUCT_RES_CODE(0xff, 0x0003);
    resourceList[0].mNumValues = 1;
    resourceList[0].mResValue.value = 778;

    handle = tuneResources(12000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

    std::this_thread::sleep_for(std::chrono::seconds(2));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Configured Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == 778));

    // This Request should be rejected by the Server, since Request duration cannot be decreased
    int8_t status = retuneResources(handle, 6000);
    std::cout<<LOG_BASE<<"Retune Status: "<<(int32_t)status<<std::endl;
    E_ASSERT((status == 0));

    std::this_thread::sleep_for(std::chrono::seconds(7));

    // Node value should still be set to the value configured via the Tune Request, as the Retune
    // Request was rejected.
    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Configured Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == 778));

    std::this_thread::sleep_for(std::chrono::seconds(6));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Reset Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == testResourceOriginalValue));

    delete[] resourceList;
})

/**
 * API under test: Retune
 * - Client can use the Retune API to extend the duration of a previously issued Tune Request.
 * - Note only the client which issue the Tune Request with H1, can issue a Retune API for H1.
 * - Retune API only supports extending the duration of a Request and not decreasing it.
 * - Here the Client issues a Tune Request for 12 seconds, and later tries to Retune it to 6 seconds.
 * - Since the Retune API does not support decreasing Request Duration, hence this Retune Request
 *   should be rejected.
 * Cross-Reference id: ['R3']
 */
URM_TEST(RequestInvalidRetuning2, {
    std::string testResourceName = "/etc/urm/tests/nodes/sched_util_clamp_min.txt";
    int32_t testResourceOriginalValue = 300;

    std::string value;
    int32_t originalValue, newValue;

    int64_t handle;

    value = AuxRoutines::readFromFile(testResourceName);
    originalValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Original Value: "<<originalValue<<std::endl;
    E_ASSERT((originalValue == testResourceOriginalValue));

    SysResource* resourceList = new SysResource[1];
    memset(&resourceList[0], 0, sizeof(SysResource));
    resourceList[0].mResCode = CONSTRUCT_RES_CODE(0xff, 0x0000);
    resourceList[0].mNumValues = 1;
    resourceList[0].mResValue.value = 597;

    handle = tuneResources(7000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

    std::this_thread::sleep_for(std::chrono::seconds(2));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Configured Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == 597));

    int32_t rc = fork();
    if(rc == 0) {
        // Child Process
        retuneResources(handle, 20000);

        exit(EXIT_SUCCESS);

    } else if(rc > 0) {
        wait(nullptr);

        // Verify that the value has reset after the original Request duration has expired
        std::this_thread::sleep_for(std::chrono::seconds(10));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        std::cout<<LOG_BASE<<testResourceName<<" Reset Value: "<<newValue<<std::endl;
        E_ASSERT((newValue == testResourceOriginalValue));

        delete[] resourceList;
    }

})

URM_TEST(TestClusterTypeResourceTuneRequest1, {
    int32_t physicalClusterID = baseline.getExpectedPhysicalCluster(0);
    if(physicalClusterID == -1) {
        LOG_SKIP("Logical Cluster: 0 not found on test device, Skipping Test Case")
        return;
    }

    std::string nodePath = "/etc/urm/tests/nodes/cluster_type_resource_%d_cluster_id.txt";

    char path[128];
    snprintf(path, sizeof(path), nodePath.c_str(), physicalClusterID);
    std::string testResourceName = std::string(path);
    int32_t testResourceOriginalValue = 180;

    std::string value;
    int32_t originalValue, newValue;

    value = AuxRoutines::readFromFile(testResourceName);
    originalValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Original Value: "<<originalValue<<std::endl;
    E_ASSERT((originalValue == testResourceOriginalValue));

    SysResource* resourceList = new SysResource[1];
    memset(&resourceList[0], 0, sizeof(SysResource));
    resourceList[0].mResCode = CONSTRUCT_RES_CODE(0xff, 0x000a);
    resourceList[0].mResInfo = SET_RESOURCE_CLUSTER_VALUE(resourceList[0].mResInfo, 0);
    resourceList[0].mNumValues = 1;
    resourceList[0].mResValue.value = 440;

    int64_t handle = tuneResources(7000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

    std::this_thread::sleep_for(std::chrono::seconds(2));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Configured Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == 440));

    std::this_thread::sleep_for(std::chrono::seconds(10));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Reset Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == testResourceOriginalValue));

    delete[] resourceList;
})

URM_TEST(ClusterTypeResourceTuneRequest2, {
    int32_t physicalClusterID = baseline.getExpectedPhysicalCluster(2);
    if(physicalClusterID == -1) {
        LOG_SKIP("Logical Cluster: 2 not found on test device, Skipping Test Case")
        return;
    }

    std::string nodePath = "/etc/urm/tests/nodes/cluster_type_resource_%d_cluster_id.txt";

    char path[128];
    snprintf(path, sizeof(path), nodePath.c_str(), physicalClusterID);
    std::string testResourceName = std::string(path);
    int32_t testResourceOriginalValue = 180;

    std::string value;
    int32_t originalValue, newValue;

    value = AuxRoutines::readFromFile(testResourceName);
    originalValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Original Value: "<<originalValue<<std::endl;
    E_ASSERT((originalValue == testResourceOriginalValue));

    SysResource* resourceList = new SysResource[1];
    memset(&resourceList[0], 0, sizeof(SysResource));
    resourceList[0].mResCode = CONSTRUCT_RES_CODE(0xff, 0x000a);
    resourceList[0].mResInfo = SET_RESOURCE_CLUSTER_VALUE(resourceList[0].mResInfo, 2);
    resourceList[0].mNumValues = 1;
    resourceList[0].mResValue.value = 440;

    int64_t handle = tuneResources(7000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

    std::this_thread::sleep_for(std::chrono::seconds(2));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Configured Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == 440));

    std::this_thread::sleep_for(std::chrono::seconds(10));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Reset Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == testResourceOriginalValue));

    delete[] resourceList;
})

/*
 * Description:
 * This Section contains tests which aim to verify that the real System Sysfs NOdes
 * are getting updated correctly by Resource Tuner.
 * Single Client Update / Reset [E1]
 * Concurrent Requests with different Config Values and Same Duration [E2]
 * Concurrent Requests with different Config Values and Differrent Duration [E3]
 * Untune a Resource Tuner Provisioning Request [E4]
 * Concurrent Requests with different Priorities [E5]
 * Retune Request durattion [E6]
 */

/**
 * API under test: Tune / Untune
 * - Issue a Resource Tuner Resource Provisioning Request, to modify the Resource
 *   sched_util_clamp_min
 * - Verify the Resource Node is Correctly updated
 * - Verify that the Resource Node is reset once the Request Expires
 * - Note these Tests need to be run with Root Privleges (sudo)
 * Cross-Reference id: ['E1']
 */
URM_TEST(TestWriteTo_sched_util_clamp_min_Node, {
    std::string testResourceName = "/proc/sys/kernel/sched_util_clamp_min";

    // Check the original value for the Resource
    std::string value = AuxRoutines::readFromFile(testResourceName);
    int32_t originalValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Original Value: "<<originalValue<<std::endl;

    if(originalValue == -1) {
        // Node does not exist on test device, can't proceed with this test
        std::cout<<LOG_BASE<<testResourceName<<"Node: "<<testResourceName<<" not found on test device, Aborting Test Case"<<std::endl;
        return;
    }

    SysResource* resourceList = new SysResource[1];
    memset(&resourceList[0], 0, sizeof(SysResource));
    resourceList[0].mResCode = CONSTRUCT_RES_CODE(0x03, 0x0000);
    resourceList[0].mNumValues = 1;
    resourceList[0].mResValue.value = 980;

    int64_t handle = tuneResources(5000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

    std::this_thread::sleep_for(std::chrono::seconds(1));

    // Check if the new value was successfully written to the node
    value = AuxRoutines::readFromFile(testResourceName);
    int32_t newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Configured Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == 980));

    std::this_thread::sleep_for(std::chrono::seconds(6));

    // Wait for the Request to expire, check if the value resets
    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Reset Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == originalValue));

    delete[] resourceList;
})

/**
 * API under test: Tune / Untune
 * - Issue 2 Concurrent Resource Tuner Resource Provisioning Requests, to modify the Resource
 *   sched_util_clamp_min
 * - Verify the Resource Node is Correctly updated to the higher of the 2 values,
 *   as the Resource has the "lower-is-better" policy.
 * - Verify that the Resource Node is reset once the Requests Expires (here both the Requests,
 *   have exactly the same duration).
 * - Note these Tests need to be run with Root Privleges (sudo)
 * Cross-Reference id: ['E2']
 */
URM_TEST(TestConcurrentWriteTo_sched_util_clamp_min_Node1, {
    std::string testResourceName = "/proc/sys/kernel/sched_util_clamp_min";

    // Check the original value for the Resource
    std::string value = AuxRoutines::readFromFile(testResourceName);
    int32_t originalValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Original Value: "<<originalValue<<std::endl;

    if(originalValue == -1) {
        // Node does not exist on test device, can't proceed with this test
        std::cout<<LOG_BASE<<testResourceName<<"Node: "<<testResourceName<<" not found on test device, Aborting Test Case"<<std::endl;
        return;
    }

    int32_t rc = fork();
    if(rc == 0) {
        SysResource* resourceList = new SysResource[1];
        memset(&resourceList[0], 0, sizeof(SysResource));
        resourceList[0].mResCode = CONSTRUCT_RES_CODE(0x03, 0x0000);
        resourceList[0].mNumValues = 1;
        resourceList[0].mResValue.value = 887;

        int64_t handle = tuneResources(8000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
        std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

        std::this_thread::sleep_for(std::chrono::seconds(3));
        delete[] resourceList;
        exit(EXIT_SUCCESS);

    } else if(rc > 0) {
        SysResource* resourceList = new SysResource[1];
        memset(&resourceList[0], 0, sizeof(SysResource));
        resourceList[0].mResCode = CONSTRUCT_RES_CODE(0x03, 0x0000);
        resourceList[0].mNumValues = 1;
        resourceList[0].mResValue.value = 799;

        int64_t handle = tuneResources(5000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
        std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

        // Verify that the higher of the two configured values, i.e. 887 takes
        // effect on the Resource Node.
        std::this_thread::sleep_for(std::chrono::seconds(1));

        // Check if the new value was successfully written to the node
        value = AuxRoutines::readFromFile(testResourceName);
        int32_t newValue = C_STOI(value);
        std::cout<<LOG_BASE<<testResourceName<<" Configured Value: "<<newValue<<std::endl;
        E_ASSERT((newValue == 799));

        std::this_thread::sleep_for(std::chrono::seconds(10));

        // Wait for the Request to expire, check if the value resets
        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        std::cout<<LOG_BASE<<testResourceName<<" Reset Value: "<<newValue<<std::endl;
        E_ASSERT((newValue == originalValue));

        delete[] resourceList;
        wait(nullptr);
    }
})

/**
 * API under test: Tune / Untune
 * - Issue 2 Concurrent Resource Tuner Resource Provisioning Requests, to modify the Resource
 *   sched_util_clamp_min
 * - Verify the Resource Node is Correctly updated to the lower of the 2 values,
 *   as the Resource has the "lower-is-better" policy.
 * - Here the Requests don't have the same duration, and the Request with a smaller config value
 *   has a higher duration.
 * - i.e. R1 (v1, d1) and R2(v2, d2) where v1 > v2 and d1 < d2
 * - Verify that the Resource Node is updated to v1 initially.
 * - Verify that the Resource Node is updated to v2 once R1 expires.
 * - Verify that the Resource Node is reset once both the Requests Expire.
 * - Note these Tests need to be run with Root Privleges (sudo)
 * Cross-Reference id: ['E3']
 */
URM_TEST(TestConcurrentWriteTo_sched_util_clamp_min_Node2, {
    std::string testResourceName = "/proc/sys/kernel/sched_util_clamp_min";

    // Check the original value for the Resource
    std::string value = AuxRoutines::readFromFile(testResourceName);
    int32_t originalValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Original Value: "<<originalValue<<std::endl;

    if(originalValue == -1) {
        // Node does not exist on test device, can't proceed with this test
        std::cout<<LOG_BASE<<testResourceName<<"Node: "<<testResourceName<<" not found on test device, Aborting Test Case"<<std::endl;
        return;
    }

    int32_t rc = fork();
    if(rc == 0) {
        SysResource* resourceList = new SysResource[1];
        memset(&resourceList[0], 0, sizeof(SysResource));
        resourceList[0].mResCode = CONSTRUCT_RES_CODE(0x03, 0x0000);
        resourceList[0].mNumValues = 1;
        resourceList[0].mResValue.value = 799;

        int64_t handle = tuneResources(8000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
        std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

        std::this_thread::sleep_for(std::chrono::seconds(3));
        delete[] resourceList;
        exit(EXIT_SUCCESS);

    } else if(rc > 0) {
        SysResource* resourceList = new SysResource[1];
        memset(&resourceList[0], 0, sizeof(SysResource));
        resourceList[0].mResCode = CONSTRUCT_RES_CODE(0x03, 0x0000);
        resourceList[0].mNumValues = 1;
        resourceList[0].mResValue.value = 887;

        int64_t handle = tuneResources(18000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
        std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

        // Verify that the lower of the two configured values, i.e. 799 takes
        // effect on the Resource Node.
        std::this_thread::sleep_for(std::chrono::seconds(2));

        // Check if the new value was successfully written to the node
        value = AuxRoutines::readFromFile(testResourceName);
        int32_t newValue = C_STOI(value);
        std::cout<<LOG_BASE<<testResourceName<<" Configured Value: "<<newValue<<std::endl;
        E_ASSERT((newValue == 799));

        std::this_thread::sleep_for(std::chrono::seconds(8));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        std::cout<<LOG_BASE<<testResourceName<<" Configured Value: "<<newValue<<std::endl;
        E_ASSERT((newValue == 887));

        std::this_thread::sleep_for(std::chrono::seconds(20));

        // Wait for the Request to expire, check if the value resets
        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        std::cout<<LOG_BASE<<testResourceName<<" Reset Value: "<<newValue<<std::endl;
        E_ASSERT((newValue == originalValue));

        delete[] resourceList;
        wait(nullptr);
    }
})

/**
 * API under test: Tune / Untune
 * - Issue a Resource Tuner Resource Provisioning Request, to modify the Resource
 *   sched_util_clamp_min for an infinite duration.
 * - Verify the Resource Node is Correctly updated
 * - Send an Untune Request, to reset the Resource Node to it's original value.
 * - Verify that the Resource Node is correctly reset.
 * - Note these Tests need to be run with Root Privleges (sudo)
 * Cross-Reference id: ['E4']
 */
URM_TEST(TestWriteTo_sched_util_clamp_min_NodeAndUntuning, {
    std::string testResourceName = "/proc/sys/kernel/sched_util_clamp_min";

    // Check the original value for the Resource
    std::string value = AuxRoutines::readFromFile(testResourceName);
    int32_t originalValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Original Value: "<<originalValue<<std::endl;

    if(originalValue == -1) {
        // Node does not exist on test device, can't proceed with this test
        std::cout<<LOG_BASE<<testResourceName<<"Node: "<<testResourceName<<" not found on test device, Aborting Test Case"<<std::endl;
        return;
    }

    SysResource* resourceList = new SysResource[1];
    memset(&resourceList[0], 0, sizeof(SysResource));
    resourceList[0].mResCode = CONSTRUCT_RES_CODE(0x03, 0x0000);
    resourceList[0].mNumValues = 1;
    resourceList[0].mResValue.value = 994;

    int64_t handle = tuneResources(-1, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

    std::this_thread::sleep_for(std::chrono::seconds(1));

    // Check if the new value was successfully written to the node
    value = AuxRoutines::readFromFile(testResourceName);
    int32_t newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Configured Value: "<<originalValue<<std::endl;
    E_ASSERT((newValue == 994));

    int8_t status = untuneResources(handle);
    std::cout<<LOG_BASE<<"Untune Status: "<<(int32_t)status<<std::endl;
    E_ASSERT((status == 0));
    std::this_thread::sleep_for(std::chrono::seconds(2));

    // Wait for the Request to expire, check if the value resets
    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Reset Value: "<<originalValue<<std::endl;
    E_ASSERT((newValue == originalValue));

    delete[] resourceList;
})

/**
* API under test: Tune / Untune
* - Issue 2 Concurrent Resource Tuner Resource Provisioning Requests, to modify the Resource
*   sched_util_clamp_min from different Clients
* - Here the Requests are submitted with different Priorities
* - Verify the Resource Node is Correctly updated to the Config Value specified by
*   the Request with the higher priority
* - Verify that the Resource Node is reset once the Requests Expire (here both the Requests,
*   have exactly the same duration).
* - Note these Tests need to be run with Root Privleges (sudo)
* Cross-Reference id: ['E5']
*/
URM_TEST(TestConcurrentWriteTo_sched_util_clamp_min_Node3, {
    std::string testResourceName = "/proc/sys/kernel/sched_util_clamp_min";

    // Check the original value for the Resource
    std::string value = AuxRoutines::readFromFile(testResourceName);
    int32_t originalValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Original Value: "<<originalValue<<std::endl;

    if(originalValue == -1) {
        // Node does not exist on test device, can't proceed with this test
        std::cout<<LOG_BASE<<testResourceName<<"Node: "<<testResourceName<<" not found on test device, Aborting Test Case"<<std::endl;
        return;
    }

    int32_t rc = fork();
    if(rc == 0) {
        SysResource* resourceList = new SysResource[1];
        memset(&resourceList[0], 0, sizeof(SysResource));
        resourceList[0].mResCode = CONSTRUCT_RES_CODE(0x03, 0x0000);
        resourceList[0].mNumValues = 1;
        resourceList[0].mResValue.value = 744;

        int64_t handle = tuneResources(8000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
        std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

        std::this_thread::sleep_for(std::chrono::seconds(3));
        delete[] resourceList;
        exit(EXIT_SUCCESS);

    } else if(rc > 0) {
        SysResource* resourceList = new SysResource[1];
        memset(&resourceList[0], 0, sizeof(SysResource));
        resourceList[0].mResCode = CONSTRUCT_RES_CODE(0x03, 0x0000);
        resourceList[0].mNumValues = 1;
        resourceList[0].mResValue.value = 801;

        int64_t handle = tuneResources(8000, RequestPriority::REQ_PRIORITY_LOW, 1, resourceList);
        std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

        // Verify that the value specified by the Request with the higher
        // priority takes effect on the Resource Node
        std::this_thread::sleep_for(std::chrono::seconds(1));

        // Check if the new value was successfully written to the node
        value = AuxRoutines::readFromFile(testResourceName);
        int32_t newValue = C_STOI(value);
        std::cout<<LOG_BASE<<testResourceName<<" Configured Value: "<<newValue<<std::endl;
        E_ASSERT((newValue == 744));

        std::this_thread::sleep_for(std::chrono::seconds(10));

        // Wait for the Request to expire, check if the value resets
        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        std::cout<<LOG_BASE<<testResourceName<<" Reset Value: "<<newValue<<std::endl;
        E_ASSERT((newValue == originalValue));

        delete[] resourceList;
        wait(nullptr);
    }
})

/**
 * API under test: Tune / Retune
 * - Issue a Resource Tuner Resource Provisioning Request, to modify the Resource
 *   sched_util_clamp_min for 5 seconds duration.
 * - Verify the Resource Node is Correctly updated
 * - Send a Retune Request, to modify the request duration to 20 seconds
 * - Verify that the Resource Node remains configured for 20 seconds.
 * - Verify the node is correctly reset once the request expires
 * - Note these Tests need to be run with Root Privleges (sudo)
 * Cross-Reference id: ['E6']
 */
URM_TEST(TestWriteTo_sched_util_clamp_min_NodeAndRetuning, {
    std::string testResourceName = "/proc/sys/kernel/sched_util_clamp_min";

    // Check the original value for the Resource
    std::string value = AuxRoutines::readFromFile(testResourceName);
    int32_t originalValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Original Value: "<<originalValue<<std::endl;

    if(originalValue == -1) {
        // Node does not exist on test device, can't proceed with this test
        std::cout<<LOG_BASE<<"Node: "<<testResourceName<<" not found on test device, Aborting Test Case"<<std::endl;
        return;
    }

    SysResource* resourceList = new SysResource[1];
    memset(&resourceList[0], 0, sizeof(SysResource));
    resourceList[0].mResCode = CONSTRUCT_RES_CODE(0x03, 0x0000);
    resourceList[0].mNumValues = 1;
    resourceList[0].mResValue.value = 994;

    int64_t handle = tuneResources(5000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;
    E_ASSERT((handle > 0));

    std::this_thread::sleep_for(std::chrono::seconds(1));

    // Check if the new value was successfully written to the node
    value = AuxRoutines::readFromFile(testResourceName);
    int32_t newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Configured Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == 994));

    int8_t status = retuneResources(handle, 20000);
    std::cout<<LOG_BASE<<"Retune Status: "<<(int32_t)status<<std::endl;
    E_ASSERT((status == 0));

    std::this_thread::sleep_for(std::chrono::seconds(2));

    // Check if the request duration is indeed extended
    std::this_thread::sleep_for(std::chrono::seconds(10));

    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Configured Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == 994));

    // Wait for the Request to expire, check if the value resets
    std::this_thread::sleep_for(std::chrono::seconds(15));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Reset Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == originalValue));

    delete[] resourceList;
})

/**
 * API under test: Tune / Untune
 * - Issue a Resource Tuner Resource Provisioning Request, to modify the Resource
 *   sched_util_clamp_min
 * - Verify the Resource Node is Correctly updated
 * - Verify that the Resource Node is reset once the Request Expires
 * - Note these Tests need to be run with Root Privleges (sudo)
 * Cross-Reference id: ['E1']
 */
URM_TEST(TestWriteTo_scaling_min_freq_Node1, {
    // Apply a value to scaling_min_freq for the Silver Cluster
    // i.e. logical cluster id = 0
    int32_t physicalClusterID = baseline.getExpectedPhysicalCluster(0);
    std::string nodePath = "/sys/devices/system/cpu/cpufreq/policy%d/scaling_min_freq";

    if(physicalClusterID == -1) {
        LOG_SKIP("Logical Cluster: 0 not found on test device, Skipping Test Case")
        return;
    }

    char path[128];
    snprintf(path, sizeof(path), nodePath.c_str(), physicalClusterID);
    std::string testResourceName = std::string(path);

    std::string originalValueString = AuxRoutines::readFromFile(testResourceName);
    int32_t originalValue = C_STOI(originalValueString);
    std::cout<<LOG_BASE<<testResourceName<<" Original Value: "<<originalValue<<std::endl;

    if(originalValue == -1) {
        // Node does not exist on test device, can't proceed with this test
        std::cout<<LOG_BASE<<"Node: "<<testResourceName<<" not found on test device, Aborting Test Case"<<std::endl;
        return;
    }

    SysResource* resourceList = new SysResource[1];
    memset(&resourceList[0], 0, sizeof(SysResource));
    resourceList[0].mResCode = CONSTRUCT_RES_CODE(0x04, 0x0000);
    resourceList[0].mNumValues = 1;
    resourceList[0].mResInfo = 0;
    // Valid Translation
    resourceList[0].mResInfo = SET_RESOURCE_CLUSTER_VALUE(resourceList[0].mResInfo, 0);
    resourceList[0].mResValue.value = 1504993;

    int64_t handle = tuneResources(5000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

    std::this_thread::sleep_for(std::chrono::seconds(1));

    // Check if the new value was successfully written to the node
    std::string value = AuxRoutines::readFromFile(testResourceName);
    int32_t newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Configured Value: "<<newValue<<std::endl;
    E_ASSERT((newValue >= 1504993));

    std::this_thread::sleep_for(std::chrono::seconds(6));

    // Wait for the Request to expire, check if the value resets
    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Reset Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == originalValue));

    delete[] resourceList;
})

/**
 * API under test: Tune / Untune
 * - Issue a Resource Tuner Resource Provisioning Request, to modify the Resource
 *   sched_util_clamp_min
 * - Verify the Resource Node is Correctly updated
 * - Verify that the Resource Node is reset once the Request Expires
 * - Note these Tests need to be run with Root Privleges (sudo)
 * Cross-Reference id: ['E1']
 */
URM_TEST(TestWriteTo_scaling_min_freq_Node2, {
    // Apply a value to scaling_min_freq for the Gold Cluster
    // i.e. logical cluster id = 1
    int32_t physicalClusterID = baseline.getExpectedPhysicalCluster(1);
    std::string nodePath = "/sys/devices/system/cpu/cpufreq/policy%d/scaling_min_freq";

    if(physicalClusterID == -1) {
        LOG_SKIP("Logical Cluster: 1 not found on test device, Skipping Test Case")
        return;
    }

    char path[128];
    snprintf(path, sizeof(path), nodePath.c_str(), physicalClusterID);
    std::string testResourceName = std::string(path);

    std::string originalValueString = AuxRoutines::readFromFile(testResourceName);
    int32_t originalValue = C_STOI(originalValueString);
    std::cout<<LOG_BASE<<testResourceName<<" Original Value: "<<originalValue<<std::endl;

    if(originalValue == -1) {
        // Node does not exist on test device, can't proceed with this test
        std::cout<<LOG_BASE<<"Node: "<<testResourceName<<" not found on test device, Aborting Test Case"<<std::endl;
        return;
    }

    SysResource* resourceList = new SysResource[1];
    memset(&resourceList[0], 0, sizeof(SysResource));
    resourceList[0].mResCode = CONSTRUCT_RES_CODE(0x04, 0x0000);
    resourceList[0].mNumValues = 1;
    resourceList[0].mResInfo = 0;
    // Valid Translation
    resourceList[0].mResInfo = SET_RESOURCE_CLUSTER_VALUE(resourceList[0].mResInfo, 1);
    resourceList[0].mResValue.value = 1664992;

    int64_t handle = tuneResources(5000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

    std::this_thread::sleep_for(std::chrono::seconds(1));

    // Check if the new value was successfully written to the node
    std::string value = AuxRoutines::readFromFile(testResourceName);
    int32_t newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Configured Value: "<<newValue<<std::endl;
    E_ASSERT((newValue >= 1664992));

    std::this_thread::sleep_for(std::chrono::seconds(6));

    // Wait for the Request to expire, check if the value resets
    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Reset Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == originalValue));

    delete[] resourceList;
})

/**
 * API under test: Tune / Untune
 * - Issue 3 Concurrent Resource Tuner Resource Provisioning Requests, to modify the Resource
 *   scaling_min_freq
 * - Verify the Resource Node is Correctly updated to the lower of the 3 values,
 *   as the Resource has the "lower-is-better" policy.
 * - Here the Requests don't have the same duration, and the Request with a smaller config value
 *   has a smaller duration.
 * - i.e. R1 (v1, d1) and R2(v2, d2) and R3(v3, d3) where v1 < v2 < v3 and d1 < d2 < d3
 * - Verify that the Resource Node is updated to v1 initially.
 * - Verify that the Resource Node is updated to v2 once R1 expires.
 * - Verify that the Resource Node is updated to v3 once R2 expires.
 * - Verify that the Resource Node is reset once all the Requests Expire.
 * - Note these Tests need to be run with Root Privleges (sudo)
 * Cross-Reference id: ['E3']
 */
URM_TEST(TestConcurrentWriteTo_scaling_min_freq_Node3, {
    // Apply a value to scaling_min_freq for the Gold Cluster
    // i.e. logical cluster id = 1
    int32_t physicalClusterID = baseline.getExpectedPhysicalCluster(1);
    std::string nodePath = "/sys/devices/system/cpu/cpufreq/policy%d/scaling_min_freq";

    if(physicalClusterID == -1) {
        LOG_SKIP("Logical Cluster: 1 not found on test device, Skipping Test Case")
        return;
    }

    char path[128];
    snprintf(path, sizeof(path), nodePath.c_str(), physicalClusterID);
    std::string testResourceName = std::string(path);

    std::string originalValueString = AuxRoutines::readFromFile(testResourceName);
    int32_t originalValue = C_STOI(originalValueString);
    std::cout<<LOG_BASE<<testResourceName<<" Original Value: "<<originalValue<<std::endl;

    if(originalValue == -1) {
        // Node does not exist on test device, can't proceed with this test
        std::cout<<LOG_BASE<<"Node: "<<testResourceName<<" not found on test device, Aborting Test Case"<<std::endl;
        return;
    }

    int32_t rc = fork();
    if(rc == 0) {
        SysResource* resourceList = new SysResource[1];
        memset(&resourceList[0], 0, sizeof(SysResource));
        resourceList[0].mResCode = CONSTRUCT_RES_CODE(0x04, 0x0000);
        resourceList[0].mNumValues = 1;
        resourceList[0].mResInfo = 0;
        // Valid Translation
        resourceList[0].mResInfo = SET_RESOURCE_CLUSTER_VALUE(resourceList[0].mResInfo, 1);
        resourceList[0].mResValue.value = 1554613;

        int64_t handle = tuneResources(10000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
        std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

        std::this_thread::sleep_for(std::chrono::seconds(3));
        delete[] resourceList;
        exit(EXIT_SUCCESS);

    } else {
        int32_t rc1 = fork();
        if(rc1 == 0) {
            SysResource* resourceList = new SysResource[1];
            memset(&resourceList[0], 0, sizeof(SysResource));
            resourceList[0].mResCode = CONSTRUCT_RES_CODE(0x04, 0x0000);
            resourceList[0].mNumValues = 1;
            resourceList[0].mResInfo = 0;
            // Valid Translation
            resourceList[0].mResInfo = SET_RESOURCE_CLUSTER_VALUE(resourceList[0].mResInfo, 1);
            resourceList[0].mResValue.value = 1656608;

            int64_t handle = tuneResources(30000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
            std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

            std::this_thread::sleep_for(std::chrono::seconds(3));
            delete[] resourceList;
            exit(EXIT_SUCCESS);

        } else {
            SysResource* resourceList = new SysResource[1];
            memset(&resourceList[0], 0, sizeof(SysResource));
            resourceList[0].mResCode = CONSTRUCT_RES_CODE(0x04, 0x0000);
            resourceList[0].mNumValues = 1;
            resourceList[0].mResInfo = 0;

            // Valid Translation
            resourceList[0].mResInfo = SET_RESOURCE_CLUSTER_VALUE(resourceList[0].mResInfo, 1);
            resourceList[0].mResValue.value = 1771209;

            int64_t handle = tuneResources(60000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
            std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

            std::this_thread::sleep_for(std::chrono::seconds(2));

            // Check if the new value was successfully written to the node
            std::string value = AuxRoutines::readFromFile(testResourceName);
            int32_t newValue = C_STOI(value);
            std::cout<<LOG_BASE<<testResourceName<<" Configured Value: "<<newValue<<std::endl;
            E_ASSERT((newValue >= 1554613));

            std::this_thread::sleep_for(std::chrono::seconds(10));

            value = AuxRoutines::readFromFile(testResourceName);
            newValue = C_STOI(value);
            std::cout<<LOG_BASE<<testResourceName<<" Configured Value: "<<newValue<<std::endl;
            E_ASSERT((newValue >= 1656608));

            std::this_thread::sleep_for(std::chrono::seconds(40));

            // Check if the new value was successfully written to the node
            value = AuxRoutines::readFromFile(testResourceName);
            newValue = C_STOI(value);
            std::cout<<LOG_BASE<<testResourceName<<" Configured Value: "<<newValue<<std::endl;
            E_ASSERT((newValue >= 1771209));

            // Wait for the Request to expire, check if the value resets
            value = AuxRoutines::readFromFile(testResourceName);
            newValue = C_STOI(value);
            std::cout<<LOG_BASE<<testResourceName<<" Reset Value: "<<newValue<<std::endl;
            E_ASSERT((newValue == originalValue));

            delete[] resourceList;

        }
    }
})

// More involved than writing to sched_util_clamp_min_Node node
// Since the condition sched_util_clamp_min_Node <= sched_util_clamp_max_Node should always
// should always be true, else kernel will reject the write request.
// Special care to be given while untuning as well, use Reverse Untune Order for
// such request.
// By defaults both nodes have a value of 1024, to change the value of sched_util_clamp_max_Node
// to say 880, we'll first need to lower sched_util_clamp_min_Node to a value < 880.
URM_TEST(TestWriteTo_sched_util_clamp_max_Node1, {
    std::string testResourceName1 = "/proc/sys/kernel/sched_util_clamp_min";

    // Check the original value for the Resource
    std::string value = AuxRoutines::readFromFile(testResourceName1);
    int32_t originalValue1 = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName1<<" Original Value: "<<originalValue1<<std::endl;

    if(originalValue1 == -1) {
        // Node does not exist on test device, can't proceed with this test
        std::cout<<LOG_BASE<<"Node: "<<testResourceName1<<" not found on test device, Aborting Test Case"<<std::endl;
        return;
    }

    SysResource* resourceList = new SysResource[1];
    memset(&resourceList[0], 0, sizeof(SysResource));
    resourceList[0].mResCode = CONSTRUCT_RES_CODE(0x03, 0x0000);
    resourceList[0].mNumValues = 1;
    resourceList[0].mResValue.value = 718;

    int64_t handle = tuneResources(25000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;
    E_ASSERT((handle > 0));

    std::this_thread::sleep_for(std::chrono::seconds(1));

    // Check if the new value was successfully written to the node
    value = AuxRoutines::readFromFile(testResourceName1);
    int32_t newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName1<<" Configured Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == 718));

    // Create another request to tune max node
    std::string testResourceName2 = "/proc/sys/kernel/sched_util_clamp_max";

    // Check the original value for the Resource
    value = AuxRoutines::readFromFile(testResourceName2);
    int32_t originalValue2 = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName2<<" Original Value: "<<originalValue2<<std::endl;

    if(originalValue2 == -1) {
        // Node does not exist on test device, can't proceed with this test
        std::cout<<LOG_BASE<<"Node: "<<testResourceName2<<" not found on test device, Aborting Test Case"<<std::endl;
        std::this_thread::sleep_for(std::chrono::seconds(30));
        return;
    }

    SysResource* resourceList2 = new SysResource[1];
    memset(&resourceList2[0], 0, sizeof(SysResource));
    resourceList2[0].mResCode = CONSTRUCT_RES_CODE(0x03, 0x0001);
    resourceList2[0].mNumValues = 1;
    resourceList2[0].mResValue.value = 880;

    handle = tuneResources(7000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList2);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

    std::this_thread::sleep_for(std::chrono::seconds(2));

    // Check if the new value was successfully written to the node
    value = AuxRoutines::readFromFile(testResourceName2);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName2<<" Configured Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == 880));

    std::this_thread::sleep_for(std::chrono::seconds(30));

    // Wait for the Request to expire, check if the value resets
    value = AuxRoutines::readFromFile(testResourceName1);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName1<<" Reset Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == originalValue1));

    value = AuxRoutines::readFromFile(testResourceName2);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName2<<" Reset Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == originalValue2));

    delete[] resourceList;
    delete[] resourceList2;
})

/**
 * API under test: Tune / Untune
 * - Issue a Resource Tuner Resource Provisioning Request, to modify the Resource
 *   sched_util_clamp_max
 * - Verify the Resource Node is Correctly updated
 * - Verify that the Resource Node is reset once the Request Expires
 * - Note these Tests need to be run with Root Privleges (sudo)
 * Cross-Reference id: ['E1']
 */
URM_TEST(TestWriteTo_sched_util_clamp_max_Node2, {
    std::string testResourceName1 = "/proc/sys/kernel/sched_util_clamp_min";

    // Check the original value for the Resource
    std::string value = AuxRoutines::readFromFile(testResourceName1);
    int32_t originalValue1 = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName1<<" Original Value: "<<originalValue1<<std::endl;

    if(originalValue1 == -1) {
        // Node does not exist on test device, can't proceed with this test
        std::cout<<LOG_BASE<<"Node: "<<testResourceName1<<" not found on test device, Aborting Test Case"<<std::endl;
        return;
    }

    SysResource* resourceList = new SysResource[1];
    memset(&resourceList[0], 0, sizeof(SysResource));
    resourceList[0].mResCode = CONSTRUCT_RES_CODE(0x03, 0x0000);
    resourceList[0].mNumValues = 1;
    resourceList[0].mResValue.value = 718;

    int64_t handle = tuneResources(45000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;
    E_ASSERT((handle > 0));

    std::this_thread::sleep_for(std::chrono::seconds(1));

    // Check if the new value was successfully written to the node
    value = AuxRoutines::readFromFile(testResourceName1);
    int32_t newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName1<<" Configured Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == 718));

    // Create another request to tune max node
    std::string testResourceName2 = "/proc/sys/kernel/sched_util_clamp_max";

    // Check the original value for the Resource
    value = AuxRoutines::readFromFile(testResourceName2);
    int32_t originalValue2 = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName2<<" Original Value: "<<originalValue2<<std::endl;

    if(originalValue2 == -1) {
        // Node does not exist on test device, can't proceed with this test
        std::cout<<LOG_BASE<<"Node: "<<testResourceName2<<" not found on test device, Aborting Test Case"<<std::endl;
        std::this_thread::sleep_for(std::chrono::seconds(60));
        return;
    }

    int32_t pid1 = fork();
    if(pid1 == 0) {
        SysResource* resourceList = new SysResource[1];
        memset(&resourceList[0], 0, sizeof(SysResource));
        resourceList[0].mResCode = CONSTRUCT_RES_CODE(0x03, 0x0001);
        resourceList[0].mNumValues = 1;
        resourceList[0].mResValue.value = 889;

        int64_t handle = tuneResources(20000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
        std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;
        std::this_thread::sleep_for(std::chrono::seconds(3));

        delete[] resourceList;
        exit(EXIT_SUCCESS);
    }

    int32_t pid2 = fork();
    if(pid2 == 0) {
        SysResource* resourceList = new SysResource[1];
        memset(&resourceList[0], 0, sizeof(SysResource));
        resourceList[0].mResCode = CONSTRUCT_RES_CODE(0x03, 0x0001);
        resourceList[0].mNumValues = 1;
        resourceList[0].mResValue.value = 955;

        int64_t handle = tuneResources(7000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
        std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;
        std::this_thread::sleep_for(std::chrono::seconds(3));

        delete[] resourceList;
        exit(EXIT_SUCCESS);
    }

    int32_t pid3 = fork();
    if(pid3 == 0) {
        SysResource* resourceList = new SysResource[1];
        memset(&resourceList[0], 0, sizeof(SysResource));
        resourceList[0].mResCode = CONSTRUCT_RES_CODE(0x03, 0x0001);
        resourceList[0].mNumValues = 1;
        resourceList[0].mResValue.value = 870;

        int64_t handle = tuneResources(15000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
        std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

        std::this_thread::sleep_for(std::chrono::seconds(3));
        delete[] resourceList;
        exit(EXIT_SUCCESS);
    }

    std::this_thread::sleep_for(std::chrono::seconds(2));

    // Check if the new value was successfully written to the node
    value = AuxRoutines::readFromFile(testResourceName2);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName2<<" Configured Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == 955));

    std::this_thread::sleep_for(std::chrono::seconds(60));

    // Wait for the Request to expire, check if the value resets
    value = AuxRoutines::readFromFile(testResourceName1);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName1<<" Reset Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == originalValue1));

    value = AuxRoutines::readFromFile(testResourceName2);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName2<<" Reset Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == originalValue2));

    waitpid(pid1, nullptr, 0);
    waitpid(pid2, nullptr, 0);
    waitpid(pid3, nullptr, 0);

    delete[] resourceList;
})

URM_TEST(TestHeavyLoadWriteTo_sched_util_clamp_min_Node, {
    std::string testResourceName = "/proc/sys/kernel/sched_util_clamp_min";

    // Check the original value for the Resource
    std::string value = AuxRoutines::readFromFile(testResourceName);
    int32_t originalValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Original Value: "<<originalValue<<std::endl;

    if(originalValue == -1) {
        // Node does not exist on test device, can't proceed with this test
        std::cout<<LOG_BASE<<"Node: "<<testResourceName<<" not found on test device, Aborting Test Case"<<std::endl;
        return;
    }

    int32_t numClients = 5;

    for(int32_t i = 0; i < numClients; i++) {
        int32_t pid = fork();
        if(pid == 0) {
            SysResource* resourceList = new SysResource[1];
            memset(&resourceList[0], 0, sizeof(SysResource));
            resourceList[0].mResCode = CONSTRUCT_RES_CODE(0x03, 0x0000);
            resourceList[0].mNumValues = 1;
            resourceList[0].mResValue.value = 800 + i;

            int64_t handle = tuneResources(8000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
            std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

            std::this_thread::sleep_for(std::chrono::seconds(3));
            delete[] resourceList;
            exit(EXIT_SUCCESS);
        }
    }

    std::this_thread::sleep_for(std::chrono::seconds(2));

    // Check if the new value was successfully written to the node
    value = AuxRoutines::readFromFile(testResourceName);
    int32_t newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Configured Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == 800));

    std::this_thread::sleep_for(std::chrono::seconds(10));

    // Wait for the Request to expire, check if the value resets
    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Reset Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == originalValue));

    for(int32_t i = 0; i < numClients; i++) {
        wait(nullptr);
    }
})

URM_TEST(TestWriteTo_pm_qos_resume_latency_us1, {
    int32_t logicalClusterID = 0;
    int32_t physicalClusterID = baseline.getExpectedPhysicalCluster(logicalClusterID);

    if(physicalClusterID == -1) {
        LOG_SKIP("Logical Cluster: 0 not found on test device, Skipping Test Case")
        return;
    }

    std::string nodePath = "/sys/devices/system/cpu/cpu%d/power/pm_qos_resume_latency_us";
    char path[128];
    snprintf(path, sizeof(path), nodePath.c_str(), physicalClusterID);
    std::string testResourceName = std::string(path);

    // Check the original value for the Resource
    std::string value = AuxRoutines::readFromFile(testResourceName);
    int32_t originalValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Original Value: "<<originalValue<<std::endl;

    if(originalValue == -1) {
        // Node does not exist on test device, can't proceed with this test
        std::cout<<LOG_BASE<<testResourceName<<"Node: "<<testResourceName<<" not found on test device, Aborting Test Case"<<std::endl;
        return;
    }

    SysResource* resourceList = new SysResource[1];
    memset(&resourceList[0], 0, sizeof(SysResource));
    resourceList[0].mResCode = CONSTRUCT_RES_CODE(0x01, 0x0001);
    resourceList[0].mResInfo = 0x00000001; // first core in little cluster
    resourceList[0].mNumValues = 1;
    resourceList[0].mResValue.value = 236;

    int64_t handle = tuneResources(7000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;
    E_ASSERT((handle > 0));

    std::this_thread::sleep_for(std::chrono::seconds(1));

    // Check if the new value was successfully written to the node
    value = AuxRoutines::readFromFile(testResourceName);
    int32_t newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Configured Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == 236));

    std::this_thread::sleep_for(std::chrono::seconds(8));

    // Wait for the Request to expire, check if the value resets
    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Reset Value: "<<newValue<<std::endl;
    if(originalValue != -1) {
        E_ASSERT((newValue == originalValue));
    }

    delete[] resourceList;
})

URM_TEST(TestWriteTo_pm_qos_resume_latency_us2, {
    int32_t physicalClusterID = baseline.getExpectedPhysicalCluster(1);
    if(physicalClusterID == -1) {
        LOG_SKIP("Logical Cluster: 1 not found on test device, Skipping Test Case")
        return;
    }

    std::string nodePath = "/sys/devices/system/cpu/cpu%d/power/pm_qos_resume_latency_us";
    char path[128];
    snprintf(path, sizeof(path), nodePath.c_str(), physicalClusterID);
    std::string testResourceName = std::string(path);

    // Check the original value for the Resource
    std::string value = AuxRoutines::readFromFile(testResourceName);
    int32_t originalValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Original Value: "<<originalValue<<std::endl;

    if(originalValue == -1) {
        // Node does not exist on test device, can't proceed with this test
        std::cout<<LOG_BASE<<testResourceName<<"Node: "<<testResourceName<<" not found on test device, Aborting Test Case"<<std::endl;
        return;
    }

    SysResource* resourceList = new SysResource[1];
    memset(&resourceList[0], 0, sizeof(SysResource));
    resourceList[0].mResCode = CONSTRUCT_RES_CODE(0x01, 0x0001);
    resourceList[0].mResInfo = 0x00000101; // first core in gold cluster
    resourceList[0].mNumValues = 1;
    resourceList[0].mResValue.value = 214;

    int64_t handle = tuneResources(7000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;
    E_ASSERT((handle > 0));

    std::this_thread::sleep_for(std::chrono::seconds(1));

    // Check if the new value was successfully written to the node
    value = AuxRoutines::readFromFile(testResourceName);
    int32_t newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Configured Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == 214));

    std::this_thread::sleep_for(std::chrono::seconds(8));

    // Wait for the Request to expire, check if the value resets
    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Reset Value: "<<newValue<<std::endl;
    if(originalValue != -1) {
        E_ASSERT((newValue == originalValue));
    }

    delete[] resourceList;
})

/*
 * Description:
 * This Section contains tests which aim to verify the correctness of Signal (GRAB / FREE) Application.
 * The tests are enumerated as follows:
 * => Single Client - Single Signal Tuning [A]
 * => Signal Untuning [B]
 */

/**
 * API under test: tuneSignal
 * - A client tries to tune a Signal, which tunes a Single Resource
 * - Verified the Resource Node is updated to the configured value
 * - Verify that the Resource Node is reset once the Signal timeouts.
 * Cross-Reference id: [A]
 */
URM_TEST(TestSingleClientTuneSignal1, {
    std::string testResourceName = "/etc/urm/tests/nodes/sched_util_clamp_min.txt";
    int32_t testResourceOriginalValue = 300;

    std::string value;
    int32_t newValue;

    value = AuxRoutines::readFromFile(testResourceName);

    int64_t handle =
        tuneSignal(
            (CONSTRUCT_SIG_CODE(0x0d, 0x0004)),
            DEFAULT_SIGNAL_TYPE,
            5000,
            RequestPriority::REQ_PRIORITY_HIGH,
            "app-name",
            "scenario-zip",
            0,
            nullptr);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

    std::this_thread::sleep_for(std::chrono::seconds(2));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    E_ASSERT((newValue == 917));

    std::this_thread::sleep_for(std::chrono::seconds(8));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    E_ASSERT((newValue == testResourceOriginalValue));
})

/**
 * API under test: tuneSignal
 * - A client tries to tune a Signal, which tunes multiple Resources
 * - Verified the Resource Node is updated to the configured value
 * - Verify that the Resource Node is reset once the Signal timeouts.
 * Cross-Reference id: [A]
 */
URM_TEST(TestSingleClientTuneSignal2, {
    std::string testResourceName1 = "/etc/urm/tests/nodes/sched_util_clamp_min.txt";
    std::string testResourceName2 = "/etc/urm/tests/nodes/sched_util_clamp_max.txt";
    std::string testResourceName3 = "/etc/urm/tests/nodes/scaling_max_freq.txt";

    int32_t originalValues[] = {300, 684, 114};

    std::string value;
    int32_t originalValue, newValue;

    value = AuxRoutines::readFromFile(testResourceName1);
    originalValue = C_STOI(value);
    E_ASSERT((originalValue == originalValues[0]));

    value = AuxRoutines::readFromFile(testResourceName2);
    originalValue = C_STOI(value);
    E_ASSERT((originalValue == originalValues[1]));

    value = AuxRoutines::readFromFile(testResourceName3);
    originalValue = C_STOI(value);
    E_ASSERT((originalValue == originalValues[2]));

    int64_t handle =
        tuneSignal(
            (CONSTRUCT_SIG_CODE(0x0d, 0x0005)),
            DEFAULT_SIGNAL_TYPE,
            5000,
            RequestPriority::REQ_PRIORITY_HIGH,
            "app-name",
            "scenario-zip",
            0,
            nullptr);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

    std::this_thread::sleep_for(std::chrono::seconds(2));

    value = AuxRoutines::readFromFile(testResourceName1);
    newValue = C_STOI(value);
    E_ASSERT((newValue == 883));

    value = AuxRoutines::readFromFile(testResourceName2);
    newValue = C_STOI(value);
    E_ASSERT((newValue == 920));

    value = AuxRoutines::readFromFile(testResourceName3);
    newValue = C_STOI(value);
    E_ASSERT((newValue == 1555));

    std::this_thread::sleep_for(std::chrono::seconds(8));

    value = AuxRoutines::readFromFile(testResourceName1);
    originalValue = C_STOI(value);
    E_ASSERT((originalValue == originalValues[0]));

    value = AuxRoutines::readFromFile(testResourceName2);
    originalValue = C_STOI(value);
    E_ASSERT((originalValue == originalValues[1]));

    value = AuxRoutines::readFromFile(testResourceName3);
    originalValue = C_STOI(value);
    E_ASSERT((originalValue == originalValues[2]));
})

URM_TEST(TestSignalUntuning, {
    std::string testResourceName = "/etc/urm/tests/nodes/sched_util_clamp_min.txt";
    int32_t testResourceOriginalValue = 300;

    std::string value;
    int32_t newValue;

    value = AuxRoutines::readFromFile(testResourceName);

    int64_t handle =
        tuneSignal(
            (CONSTRUCT_SIG_CODE(0x0d, 0x0004)),
            DEFAULT_SIGNAL_TYPE,
            -1,
            RequestPriority::REQ_PRIORITY_HIGH,
            "app-name",
            "scenario-zip",
            0,
            nullptr);

    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

    std::this_thread::sleep_for(std::chrono::seconds(2));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Configured Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == 917));

    std::this_thread::sleep_for(std::chrono::seconds(8));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    E_ASSERT((newValue == 917));

    int8_t status = untuneSignal(handle);
    E_ASSERT((status == 0));

    std::this_thread::sleep_for(std::chrono::seconds(2));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Reset Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == testResourceOriginalValue));
})

// Observe only as of now
URM_TEST(TestObservationSignal, {
    std::vector<std::string> keys = {
        "/sys/fs/cgroup/camera-cgroup/cgroup.procs",
        "/sys/fs/cgroup/user.slice/cgroup.procs",
        "/sys/fs/cgroup/system.slice/cpu.weight",
        "/sys/fs/cgroup/system.slice/cpuset.cpus",
        "/sys/fs/cgroup/user.slice/cpuset.cpus",
        "/sys/fs/cgroup/user.slice/cpu.weight",
        "/sys/fs/cgroup/user.slice/memory.high",
        "/sys/fs/cgroup/camera-cgroup/cpuset.cpus",
        "/sys/fs/cgroup/camera-cgroup/cpu.weight",
        "/sys/fs/cgroup/camera-cgroup/cpu.weight.nice",
        "/sys/fs/cgroup/camera-cgroup/memory.low",
        "/sys/fs/cgroup/camera-cgroup/memory.min",
        "/sys/devices/system/cpu/cpufreq/policy0/scaling_max_freq",
        "/sys/devices/system/cpu/cpufreq/policy4/scaling_max_freq",
        "/sys/devices/system/cpu/cpufreq/policy7/scaling_max_freq",
    };

    std::cout<<"Initial"<<std::endl;
    for(const std::string& key: keys) {
        std::cout<<key<<": ["<<AuxRoutines::readFromFile(key)<<"]"<<std::endl;
    }

    uint32_t* list = (uint32_t*) calloc(3, sizeof(uint32_t));
    list[0] = getpid();
    list[1] = getppid();
    list[2] = 2010;

    int64_t handle = tuneSignal(
        (CONSTRUCT_SIG_CODE(0x0d, 0x0009)),
        DEFAULT_SIGNAL_TYPE,
        0, 0, "", "",
        3,
        list);

    E_ASSERT((handle > 0));

    std::this_thread::sleep_for(std::chrono::seconds(3));

    std::cout<<"Request Applied"<<std::endl;
    for(const std::string& key: keys) {
        std::cout<<key<<": ["<<AuxRoutines::readFromFile(key)<<"]"<<std::endl;
    }

    std::this_thread::sleep_for(std::chrono::seconds(60));

    std::cout<<"Request Reset"<<std::endl;
    for(const std::string& key: keys) {
        std::cout<<key<<": ["<<AuxRoutines::readFromFile(key)<<"]"<<std::endl;
    }
})

static std::string encodeCluster(const std::string& nodePath, int32_t physicalClusterID) {
    char path[128];
    snprintf(path, sizeof(path), nodePath.c_str(), physicalClusterID);
    return std::string(path);
}

URM_TEST(TestMultiResourceSignal, {
    std::string clusResource = "/etc/urm/tests/nodes/cluster_type_resource_%d_cluster_id.txt";
    int32_t physicalClusterID0 = baseline.getExpectedPhysicalCluster(0);
    int32_t physicalClusterID1 = baseline.getExpectedPhysicalCluster(1);
    int32_t physicalClusterID2 = baseline.getExpectedPhysicalCluster(2);

    std::vector<ResourceHolder> tunedResources = {
        {
            .name = "/etc/urm/tests/nodes/sched_util_clamp_min.txt",
            .expectedValue = 668,
            .originalValue = -1,
        },
        {
            .name = "/etc/urm/tests/nodes/sched_util_clamp_max.txt",
            .expectedValue = 897,
            .originalValue = -1,
        },
        {
            .name = "/etc/urm/tests/nodes/target_test_resource1.txt",
            .expectedValue = 231,
            .originalValue = -1
        },
        {
            .name = "/etc/urm/tests/nodes/scaling_max_freq.txt",
            .expectedValue = 1533,
            .originalValue = -1
        },
        {
            .name = (physicalClusterID0 == -1) ? "" : encodeCluster(clusResource, physicalClusterID0),
            .expectedValue = (physicalClusterID0 == -1) ? -1 : 1976,
            .originalValue = -1
        },
        {
            .name = (physicalClusterID1 == -1) ? "" : encodeCluster(clusResource, physicalClusterID1),
            .expectedValue = (physicalClusterID1 == -1) ? -1 : 1989,
            .originalValue = -1
        },
        {
            .name = (physicalClusterID2 == -1) ? "" : encodeCluster(clusResource, physicalClusterID2),
            .expectedValue = (physicalClusterID2 == -1) ? -1 : 2012,
            .originalValue = -1
        },
        {
            .name = "/etc/urm/tests/nodes/target_test_resource4.txt",
            .expectedValue = 41128,
            .originalValue = -1
        },
    };

    // Record original values
    for(int32_t i = 0; i < (int32_t)tunedResources.size(); i++) {
        if(tunedResources[i].name.length() > 0) {
            tunedResources[i].originalValue = C_STOI(AuxRoutines::readFromFile(tunedResources[i].name));
        }
    }

    // Tune the Signal
    int64_t handle = tuneSignal(
        (CONSTRUCT_SIG_CODE(0x0d, 0x000a)),
        DEFAULT_SIGNAL_TYPE,
        0, 0, "", "", 0, nullptr);

    E_ASSERT((handle > 0));

    std::this_thread::sleep_for(std::chrono::seconds(2));

    // Test Tuning
    for(int32_t i = 0; i < (int32_t)tunedResources.size(); i++) {
        if(tunedResources[i].name.length() > 0) {
            int32_t curValue = C_STOI(AuxRoutines::readFromFile(tunedResources[i].name));
            std::cout<<LOG_BASE<<tunedResources[i].name<<" Configured Value: "<<curValue<<std::endl;
            std::cout<<LOG_BASE<<tunedResources[i].name<<" Expected Config Val: "<<tunedResources[i].expectedValue<<std::endl;
            E_ASSERT((curValue == tunedResources[i].expectedValue));
        }
    }

    std::this_thread::sleep_for(std::chrono::seconds(10));

    // Test Resetting
    for(int32_t i = 0; i < (int32_t)tunedResources.size(); i++) {
        if(tunedResources[i].name.length() > 0) {
            int32_t curValue = C_STOI(AuxRoutines::readFromFile(tunedResources[i].name));
            std::cout<<LOG_BASE<<tunedResources[i].name<<" Configured Value: "<<curValue<<std::endl;
            std::cout<<LOG_BASE<<tunedResources[i].name<<" Expected Reset Val: "<<tunedResources[i].originalValue<<std::endl;
            E_ASSERT((curValue == tunedResources[i].originalValue));
        }
    }
})

URM_TEST(TestCgroupWriteAndResetBasicCase, {
    std::string testResourceName = "/sys/fs/cgroup/audio-cgroup/cpu.uclamp.min";

    std::string originalValueString = AuxRoutines::readFromFile(testResourceName);
    int32_t originalValue = C_STOI(originalValueString);

    SysResource* resourceList = new SysResource[1];
    memset(&resourceList[0], 0, sizeof(SysResource));
    resourceList[0].mResCode = CONSTRUCT_RES_CODE(0x09, 0x0007);
    resourceList[0].mNumValues = 2;
    resourceList[0].mResValue.values = new int32_t[resourceList[0].mNumValues];
    resourceList[0].mResValue.values[0] = 802;
    resourceList[0].mResValue.values[1] = 52;

    int64_t handle = tuneResources(8000, RequestPriority::REQ_PRIORITY_LOW, 1, resourceList);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;
    E_ASSERT((handle > 0));

    std::this_thread::sleep_for(std::chrono::seconds(2));

    std::string value;
    int32_t newValue;

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Configured Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == 52));

    std::this_thread::sleep_for(std::chrono::seconds(10));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName<<" Reset Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == originalValue));

    delete[] resourceList;
})

URM_TEST(TestCgroupWriteAndReset1, {
    std::string testResourceName = "/sys/fs/cgroup/audio-cgroup/cpu.uclamp.min";

    std::string originalValueString = AuxRoutines::readFromFile(testResourceName);
    int32_t originalValue = C_STOI(originalValueString);

    SysResource* resourceList1 = new SysResource[1];
    memset(&resourceList1[0], 0, sizeof(SysResource));
    resourceList1[0].mResCode = CONSTRUCT_RES_CODE(0x09, 0x0007);
    resourceList1[0].mNumValues = 2;
    resourceList1[0].mResValue.values = new int32_t[2];
    resourceList1[0].mResValue.values[0] = 802;
    resourceList1[0].mResValue.values[1] = 52;
    int64_t handle = tuneResources(25000, RequestPriority::REQ_PRIORITY_LOW, 1, resourceList1);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

    std::this_thread::sleep_for(std::chrono::seconds(2));

    SysResource* resourceList = new SysResource[1];
    memset(&resourceList[0], 0, sizeof(SysResource));
    resourceList[0].mResCode = CONSTRUCT_RES_CODE(0x09, 0x0007);
    resourceList[0].mNumValues = 2;
    resourceList[0].mResValue.values = new int32_t[2];
    resourceList[0].mResValue.values[0] = 802;
    resourceList[0].mResValue.values[1] = 57;
    handle = tuneResources(8000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

    std::string value;
    int32_t newValue;

    std::this_thread::sleep_for(std::chrono::seconds(2));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    E_ASSERT((newValue == 57));

    std::this_thread::sleep_for(std::chrono::seconds(8));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    E_ASSERT((newValue == 52));

    std::this_thread::sleep_for(std::chrono::seconds(20));

    value = AuxRoutines::readFromFile(testResourceName);
    newValue = C_STOI(value);
    E_ASSERT((newValue == originalValue));

    delete[] resourceList;
    delete[] resourceList1;
})

URM_TEST(TestCgroupWriteAndReset2, {
    std::string testResourceName = "/sys/fs/cgroup/audio-cgroup/cpu.uclamp.min";

    std::string originalValueString = AuxRoutines::readFromFile(testResourceName);
    int32_t originalValue = C_STOI(originalValueString);

    int32_t rc = fork();
    if(rc == 0) {
        SysResource* resourceList = new SysResource[1];
        memset(&resourceList[0], 0, sizeof(SysResource));
        resourceList[0].mResCode = CONSTRUCT_RES_CODE(0x09, 0007);
        resourceList[0].mNumValues = 2;
        resourceList[0].mResValue.values = new int32_t[2];
        resourceList[0].mResValue.values[0] = 802;
        resourceList[0].mResValue.values[1] = 53;

        int64_t handle = tuneResources(8000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
        std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

        std::this_thread::sleep_for(std::chrono::seconds(3));
        delete[] resourceList;
        exit(EXIT_SUCCESS);

    } else if(rc > 0) {
        SysResource* resourceList = new SysResource[1];
        memset(&resourceList[0], 0, sizeof(SysResource));
        resourceList[0].mResCode = CONSTRUCT_RES_CODE(0x09, 0x0007);
        resourceList[0].mNumValues = 2;
        resourceList[0].mResValue.values = new int32_t[2];
        resourceList[0].mResValue.values[0] = 802;
        resourceList[0].mResValue.values[1] = 57;

        int64_t handle = tuneResources(8000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
        std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

        std::string value;
        int32_t newValue;

        std::this_thread::sleep_for(std::chrono::seconds(2));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        E_ASSERT((newValue == 53));

        std::this_thread::sleep_for(std::chrono::seconds(10));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        E_ASSERT((newValue == originalValue));

        delete[] resourceList;
        wait(nullptr);
    }
})

URM_TEST(TestCgroupWriteAndReset3, {
    std::string testResourceName = "/sys/fs/cgroup/audio-cgroup/cpu.uclamp.max";

    std::string originalValueString = AuxRoutines::readFromFile(testResourceName);
    std::cout<<"["<<__LINE__<<"]"<<" cpu.uclamp.max Original Value: "<<originalValueString<<std::endl;
    int32_t originalValue = C_STOI(originalValueString);

    int32_t rc = fork();
    if(rc == 0) {
        SysResource* resourceList = new SysResource[1];
        memset(&resourceList[0], 0, sizeof(SysResource));
        resourceList[0].mResCode = CONSTRUCT_RES_CODE(0x09, 0x0008);
        resourceList[0].mNumValues = 2;
        resourceList[0].mResValue.values = new int32_t[2];
        resourceList[0].mResValue.values[0] = 802;
        resourceList[0].mResValue.values[1] = 75;

        int64_t handle = tuneResources(8000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
        std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

        std::this_thread::sleep_for(std::chrono::seconds(2));
        delete[] resourceList;
        exit(EXIT_SUCCESS);

    } else if(rc > 0) {
        SysResource* resourceList = new SysResource[1];
        memset(&resourceList[0], 0, sizeof(SysResource));
        resourceList[0].mResCode = CONSTRUCT_RES_CODE(0x09, 0x0008);
        resourceList[0].mNumValues = 2;
        resourceList[0].mResValue.values = new int32_t[2];
        resourceList[0].mResValue.values[0] = 802;
        resourceList[0].mResValue.values[1] = 68;

        int64_t handle = tuneResources(8000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
        std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

        std::string value;
        int32_t newValue;

        std::this_thread::sleep_for(std::chrono::seconds(2));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        E_ASSERT((newValue == 75));

        std::this_thread::sleep_for(std::chrono::seconds(10));

        value = AuxRoutines::readFromFile(testResourceName);
        std::cout<<"["<<__LINE__<<"]"<<" cpu.uclamp.max Reset Value: "<<value<<std::endl;
        newValue = C_STOI(value);
        if(newValue != -1 && originalValue != -1) {
            E_ASSERT((newValue == originalValue));
        }

        delete[] resourceList;
        wait(nullptr);
    }
})

URM_TEST(TestCgroupWriteAndReset4, {
    std::string testResourceName = "/sys/fs/cgroup/audio-cgroup/memory.max";

    std::string originalValueString = AuxRoutines::readFromFile(testResourceName);
    int32_t originalValue = C_STOI(originalValueString);
    std::cout<<LOG_BASE<<testResourceName<<" Original Value: "<<originalValue<<std::endl;

    int32_t rc = fork();
    if(rc == 0) {
        SysResource* resourceList = new SysResource[1];
        memset(&resourceList[0], 0, sizeof(SysResource));
        resourceList[0].mResCode = CONSTRUCT_RES_CODE(0x09, 0x000b);
        resourceList[0].mNumValues = 2;
        resourceList[0].mResValue.values = new int32_t[2];
        resourceList[0].mResValue.values[0] = 802;
        resourceList[0].mResValue.values[1] = 1224;

        int64_t handle = tuneResources(8000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
        std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

        std::this_thread::sleep_for(std::chrono::seconds(2));
        delete[] resourceList;
        exit(EXIT_SUCCESS);

    } else if(rc > 0) {
        SysResource* resourceList = new SysResource[1];
        memset(&resourceList[0], 0, sizeof(SysResource));
        resourceList[0].mResCode = CONSTRUCT_RES_CODE(0x09, 0x000b);
        resourceList[0].mNumValues = 2;
        resourceList[0].mResValue.values = new int32_t[2];
        resourceList[0].mResValue.values[0] = 802;
        resourceList[0].mResValue.values[1] = 950; // KB as per configs

        int64_t handle = tuneResources(8000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList);
        std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;

        std::string value;
        int32_t newValue;

        std::this_thread::sleep_for(std::chrono::seconds(2));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        std::cout<<LOG_BASE<<testResourceName<<" Configured Value: "<<newValue<<std::endl;
        E_ASSERT((newValue > 950 * 1024));
        E_ASSERT((newValue <= 1224 * 1024));

        std::this_thread::sleep_for(std::chrono::seconds(10));

        value = AuxRoutines::readFromFile(testResourceName);
        newValue = C_STOI(value);
        if(newValue != -1 && originalValue != -1) {
            std::cout<<LOG_BASE<<testResourceName<<" Reset Value: "<<newValue<<std::endl;
            E_ASSERT((newValue == originalValue));
        }

        delete[] resourceList;
        wait(nullptr);
    }
})

// Multiple CGroups in a single Request
URM_TEST(TestCgroupWriteAndReset5,  {
    std::string testResourceName1 = "/sys/fs/cgroup/camera-cgroup/cpu.uclamp.min";
    std::string testResourceName2 = "/sys/fs/cgroup/audio-cgroup/cpu.uclamp.min";

    std::string originalValueString = AuxRoutines::readFromFile(testResourceName1);
    int32_t originalValue1 = C_STOI(originalValueString);
    std::cout<<LOG_BASE<<testResourceName1<<" Original Value: "<<originalValue1<<std::endl;

    originalValueString = AuxRoutines::readFromFile(testResourceName2);
    std::cout<<"["<<__LINE__<<"]"<<" 1) cpu.uclamp.min Original Value: "<<originalValueString<<std::endl;
    int32_t originalValue2 = C_STOI(originalValueString);
    std::cout<<LOG_BASE<<testResourceName2<<" Original Value: "<<originalValue2<<std::endl;

    SysResource* resourceList = new SysResource[2];
    memset(&resourceList[0], 0, sizeof(SysResource));
    resourceList[0].mResCode = CONSTRUCT_RES_CODE(0x09, 0x0007);
    resourceList[0].mNumValues = 2;
    resourceList[0].mResValue.values = new int32_t[2];
    resourceList[0].mResValue.values[0] = 801;
    resourceList[0].mResValue.values[1] = 55;

    memset(&resourceList[1], 0, sizeof(SysResource));
    resourceList[1].mResCode = CONSTRUCT_RES_CODE(0x09, 0x0007);
    resourceList[1].mNumValues = 2;
    resourceList[1].mResValue.values = new int32_t[2];
    resourceList[1].mResValue.values[0] = 802;
    resourceList[1].mResValue.values[1] = 58;

    int64_t handle = tuneResources(8000, RequestPriority::REQ_PRIORITY_LOW, 2, resourceList);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;
    E_ASSERT((handle > 0));

    std::string value;
    int32_t newValue;

    std::this_thread::sleep_for(std::chrono::seconds(2));

    value = AuxRoutines::readFromFile(testResourceName1);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName1<<" Configured Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == 55));

    value = AuxRoutines::readFromFile(testResourceName2);
    newValue = C_STOI(value);
    std::cout<<LOG_BASE<<testResourceName2<<" Configured Value: "<<newValue<<std::endl;
    E_ASSERT((newValue == 58));

    std::this_thread::sleep_for(std::chrono::seconds(10));

    value = AuxRoutines::readFromFile(testResourceName1);
    newValue = C_STOI(value);
    if(newValue != -1 && originalValue1 != -1) {
        std::cout<<LOG_BASE<<testResourceName1<<" Reset Value: "<<newValue<<std::endl;
        E_ASSERT((newValue == originalValue1));
    }

    value = AuxRoutines::readFromFile(testResourceName2);
    newValue = C_STOI(value);
    if(newValue != -1 && originalValue2 != -1) {
        std::cout<<LOG_BASE<<testResourceName2<<" Reset Value: "<<newValue<<std::endl;
        E_ASSERT((newValue == originalValue2));
    }

    delete[] resourceList;
})

URM_TEST(TestCgroupWriteAndReset6, {
    std::string testResourceName = "/sys/fs/cgroup/audio-cgroup/cpuset.cpus";

    std::string originalValueString = AuxRoutines::readFromFile(testResourceName);

    SysResource* resourceList1 = new SysResource[1];
    memset(&resourceList1[0], 0, sizeof(SysResource));
    resourceList1[0].mResCode = CONSTRUCT_RES_CODE(0x09, 0x0002);
    resourceList1[0].mNumValues = 4;
    resourceList1[0].mResValue.values = new int32_t[resourceList1[0].mNumValues];
    resourceList1[0].mResValue.values[0] = 802;
    resourceList1[0].mResValue.values[1] = 0;
    resourceList1[0].mResValue.values[2] = 1;
    resourceList1[0].mResValue.values[3] = 3;

    int64_t handle = tuneResources(8000, RequestPriority::REQ_PRIORITY_HIGH, 1, resourceList1);
    std::cout<<LOG_BASE<<"Handle Returned: "<<handle<<std::endl;
    E_ASSERT((handle > 0));

    std::this_thread::sleep_for(std::chrono::seconds(2));

    std::string value;

    value = AuxRoutines::readFromFile(testResourceName);
    std::cout<<LOG_BASE<<testResourceName<<" Configured Value: "<<value<<std::endl;
    E_ASSERT((value == "0-1,3"));

    std::this_thread::sleep_for(std::chrono::seconds(10));

    value = AuxRoutines::readFromFile(testResourceName);
    std::cout<<LOG_BASE<<testResourceName<<" Reset Value: "<<value<<std::endl;
    E_ASSERT((value == originalValueString));

    delete[] resourceList1;
})

REGISTER_AND_TRIGGER_SUITE(TEST_CLASS)
